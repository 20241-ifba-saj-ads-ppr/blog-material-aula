import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,a as s,o as t}from"./app-BrOvOMMH.js";const r={};function i(d,e){return t(),o("div",null,e[0]||(e[0]=[s('<h1 id="adapter" tabindex="-1"><a class="header-anchor" href="#adapter"><span>Adapter</span></a></h1><p>O Adapter é um padrão de projeto estrutural que permite objetos com interfaces incompatíveis colaborarem entre si.</p><h2 id="intencao" tabindex="-1"><a class="header-anchor" href="#intencao"><span>Intenção</span></a></h2><p>Converter a interface de uma classe em outra interface, esperada pelos clientes. O Adapter permite que classes com interfaces incompatíveis trabalhem em conjunto – o que, de outra forma, seria impossível.</p><h2 id="tambem-conhecido-como" tabindex="-1"><a class="header-anchor" href="#tambem-conhecido-como"><span>Também conhecido como</span></a></h2><p>Wrapper</p><h2 id="motivacao" tabindex="-1"><a class="header-anchor" href="#motivacao"><span>Motivação</span></a></h2><p>Algumas vezes, uma classe de um toolkit, projetada para ser reutilizada não é reutilizável porque sua interface não corresponde à interface específica de um domínio requerida por uma aplicação.</p><p>Considere, por exemplo, um editor de desenhos que permite aos usuários desenhar e arranjar elementos gráficos (linhas, polígonos, texto, etc.) em figuras e diagramas. A abstração-chave do editor de desenhos é o objeto gráfico, o qual tem uma forma editável e pode desenhar a si próprio. A interface para objetos gráficos é definida por uma classe abstrata chamada Shape. O editor define uma subclasse de Shape para cada tipo de objeto gráfico: uma classe LineShape para linhas, uma classe PolygonShape para polígonos, e assim por diante.</p><p>Classes para formas geométricas elementares, como LineShape e PolygonShape, são bastante fáceis de ser implementadas porque as suas capacidades de desenho e edição são inerentemente limitadas. Mas uma subclasse TextShape que pode exibir e editar textos é mais difícil de ser implementada, uma vez que mesmo a edição básica de textos envolve atualizações complicadas de tela e gerência de buffer. Entretanto, pode já existir um toolkit para construção de interfaces de usuários, o qual já oferece uma sofisticada classe TextView para a exibição e edição de textos. Idealmente, gostaríamos de reutilizar TextView para implementar TextShape, porém, o toolkit não foi projetado levando classes Shape em consideração. Assim, não podemos usar de maneira intercambiável objetos TextView e Shape.</p><p>Como é possível que classes existentes e não-relacionadas, como TextView, funcionem em uma aplicação que espera classes com uma interface diferente e incompatível? Poderíamos mudar a classe TextView de maneira que ela fosse coerente com a interface de Shape, porém, a menos que tenhamos o código-fonte do toolkit, essa opção não é viável. Mesmo que tivéssemos o código-fonte, não teria sentido mudar TextView; o toolkit não deveria ter que adotar interfaces específicas de domínios somente para fazer com que uma aplicação funcione.</p><p>Em vez disso, poderíamos definir TextShape de maneira que ele adapte a interface de TextView àquela de Shape. Podemos fazer isto de duas maneiras: (1) herdando a interface de Shape e a implementação de TextView, ou (2) compondo uma instância de TextView dentro de uma TextShape e implementando TextShape em termos da interface de TextView.</p><p>Essas duas abordagens correspondem às versões do padrão Adapter para classes e para objetos. Chamamos TextShape um adaptador.</p><figure><img src="https://github.com/user-attachments/assets/cb39c6fa-5ebb-4f6f-91af-891bd4a05f54" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>Este diagrama ilustra o caso de um adaptador para objetos. Ele mostra como solicitações de BoundingBox, declarada na classe Shape, são convertidas em solicitações para GetExtent, definida em TextView. Uma vez que TextShape adapta Text View à interface de Shape, o editor de desenhos pode reutilizar a classe TextView que seria incompatível de outra forma.</p><p>Freqüentemente, um adaptador é responsável por funcionalidades não oferecidas pela classe adaptada. O diagrama mostra como um adaptador pode atender tais responsabilidades. O usuário deveria ser capaz de “arrastar” cada objeto Shape para uma nova posição de forma interativa, porém, TextView não está projetada para fazer isso. TextShape pode acrescentar essa função através da implementação da operação CreateManipulator, de Shape, a qual retorna uma instância da subclasse Manipulator apropriada.</p><p>Manipulator é uma classe abstrata para objetos que sabem como animar um Shape em resposta à entrada de usuário, tal como arrastar a forma geométrica para uma nova localização. Existem subclasses de Manipulator para diferentes formas; por exemplo, TextManipulator é a subclasse correspondente para TextShape. Pelo retorno de uma instância de TextManipulator, TextShape acrescenta a funcionalidade que Shape necessita mas que TextView não tem.</p><h2 id="aplicabilidade" tabindex="-1"><a class="header-anchor" href="#aplicabilidade"><span>Aplicabilidade</span></a></h2><p>Use o padrão Adapter quando:</p><ul><li>você quiser usar uma classe existente, mas sua interface não corresponder à interface de que necessita;</li><li>você quiser criar uma classe reutilizável que coopere com classes não-relacionadas ou não-previstas, ou seja, classes que não necessariamente tenham interfaces compatíveis:</li><li>(somente para adaptadores de objetos) você precisar usar várias subclasses existentes, porém, for impraticável adaptar essas interfaces criando subclasses para cada uma. Um adaptador de objeto pode adaptar a interface da sua classe-mãe.</li></ul><h2 id="estrutura" tabindex="-1"><a class="header-anchor" href="#estrutura"><span>Estrutura</span></a></h2><ul><li><p>Um adaptador de classe usa a herança múltipla para adaptar uma interface à outra: <img src="https://github.com/user-attachments/assets/2e8051f5-8b9d-4687-b54f-85e2b924e65b" alt="image" loading="lazy"></p></li><li><p>Um adaptador de objeto depende da composição de objetos: <img src="https://github.com/user-attachments/assets/2943d0e9-5bd0-420f-9547-a7815c0d2836" alt="image" loading="lazy"></p></li></ul><h2 id="participantes" tabindex="-1"><a class="header-anchor" href="#participantes"><span>Participantes</span></a></h2><ul><li>Target (Shape): define a interface específica do domínio que Client usa.</li><li>Client (DrawingEditor): colabora com objetos compatíveis com a interface de Target.</li><li>Adaptee (TextView): define uma interface existente que necessita ser adaptada.</li><li>Adapter (TextShape): adapta a interface do Adaptee à interface de Target.</li></ul><h2 id="colaboracoes" tabindex="-1"><a class="header-anchor" href="#colaboracoes"><span>Colaborações</span></a></h2><p>• Os clientes chamam operações em uma instância de Adapter. Por sua vez, o adapter chama operações de Adaptee que executam a solicitação.</p><h2 id="consequencias" tabindex="-1"><a class="header-anchor" href="#consequencias"><span>Conseqüências</span></a></h2><p>Os adaptadores de classes e de objetos têm diferentes soluções de compromisso. Um adaptador de classe:</p><ul><li>adapta Adaptee a Target através do uso efetivo de uma classe Adapter concreta. Em conseqüência, um adaptador de classe não funcionará quando quisermos adaptar uma classe e todas as suas subclasses;</li><li>permite a Adapter substituir algum comportamento do Adaptee, uma vez que Adapter é uma subclasse de Adaptee;</li><li>introduz somente um objeto, e não é necessário endereçamento indireto adicional por ponteiros para chegar até o Adaptee.</li></ul><p>Um adaptador de objeto:</p><ul><li>permite a um único Adapter trabalhar com muitos Adaptees – isto é, o Adaptee em si e todas as suas subclasses (se existirem). O Adapter também pode acrescentar funcionalidade a todos os Adaptees de uma só vez;</li><li>torna mais difícil redefinir um comportamento de Adaptee. Ele exigirá a criação de subclasses de Adaptee e fará com que Adapter referencie a subclasse ao invés do Adaptee em si.</li></ul><p>Aqui apresentamos outros pontos a serem considerados quando usamos o padrão Adapter:</p><ol><li><p>Quanta adaptação Adapter faz? Os Adapters variam no volume de trabalho que executam para adaptar o Adaptee à interface de Target. Existe uma variação do trabalho possível, desde a simples conversão de interface – por exemplo, mudar os nomes das operações – até suportar um conjunto de operações inteiramente diferente. O volume de trabalho que o Adapter executa depende de quão similar é a interface de Target a dos seus Adaptees.</p></li><li><p>Adaptadores conectáveis (pluggable). Uma classe é mais reutilizável quando você minimiza as suposições que outras classes devem fazer para utilizá-la. Através da construção da adaptação de interface em uma classe, você elimina a suposição de que outras classes vêm a mesma interface. Dito de outra maneira, a adaptação de interfaces permite incorporar a nossa classe a sistemas existentes que podem estar esperando interfaces diferentes para a classe. ObjectWorks/ Smalltalk [Par90] usa o termo pluggable adapter para descrever classes com adaptação de interfaces incorporadas. Considere um widget TreeDisplay que pode exibir graficamente estruturas de árvore. Se este fosse um widget com uma finalidade especial para uso em apenas uma aplicação, então, poderíamos requerer uma interface específica dos objetos que ele exibisse; ou seja, todos deveriam descender de uma classe abstrata Tree. Mas se quiséssemos tornar TreeDisplay mais reutilizável (digamos que quiséssemos torná-la parte de um toolkit de widgets úteis), então essa exigência não seria razoável. Aplicações definirão suas próprias classes para estruturas de árvore. Elas não deveriam ser forçadas a usar a nossa classe abstrata Tree. Diferentes estruturas de árvores terão diferentes interfaces. Por exemplo, numa hierarquia de diretório, os descendentes podem ser acessados com uma operação GetSubdirectories, enquanto que numa hierarquia de herança, a operação correspondente poderia ser chamada GetSubclasses. Um widget TreeDisplay reutilizável deve ser capaz de exibir ambos os tipos de hierarquias ainda que usem interfaces diferentes. Em outras palavras, TreeDisplay deveria ter uma adaptação de interface incorporada a ele. Examinaremos diferentes maneiras de construir adaptações de interfaces, dentro de classes, na seção Implementação.</p></li><li><p>Utilização de adaptadores de dois sentidos para fornecer transparência. Um problema potencial com adaptadores decorre do fato de que eles não são transparentes para todos os clientes. Um objeto adaptado não oferece a interface do objeto original, por isso ele não pode ser usado onde o original o for. Adaptadores de dois sentidos (two-way adapters) podem fornecer essa transparência. Eles são úteis quando dois clientes diferentes necessitam ver um objeto de forma diferente. Considere o adaptador de dois sentidos que integra o Unidraw, um framework para editores gráficos [VL90], e QOCA, um toolkit para solução de restrições [HHMV92]. Ambos os sistemas possuem classes que representam variáveis explicitamente: Unidraw tem StateVariable e QOCA tem Constraint Variable. Para fazer com que Unidraw trabalhe com QOCA, Constraint Variable deve ser adaptada a StateVariable; para permitir que QOCA propague soluções para Unidraw, StateVariable deve ser adaptada a ConstraintVariable.</p></li></ol><figure><img src="https://github.com/user-attachments/assets/fcba4481-44b9-4d12-ba7a-51815367538e" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>A solução envolve o uso de um adaptador de classe ConstraintStateVariable de dois sentidos, uma subclasse tanto de StateVariable como de ConstraintVariable que adapta as duas interfaces uma à outra. Neste caso, a herança múltipla é uma solução viável porque as interfaces das classes adaptadas são substancialmente diferentes. O adaptador de classe de dois sentidos é compatível com ambas as classes adaptadas, podendo funcionar em ambos os sistemas.</p><h2 id="implementacao" tabindex="-1"><a class="header-anchor" href="#implementacao"><span>Implementação</span></a></h2><p>Embora a implementação do padrão Adapter seja normalmente simples e direta, apresentamos aqui alguns tópicos a serem sempre considerados:</p><ol><li>Implementando adaptadores de classe em C++. Numa implementação em C++ uma classe Adapter deveria herdar publicamente de Target e privadamente de Adaptee. Assim, Adapter seria um subtipo de Target, mas não de Adaptee.</li><li>Adaptadores conectáveis. Vamos examinar três maneiras de implementar adaptadores “plugáveis” para o widget TreeDisplay descrito anteriormente, os quais podem formatar e exibir uma estrutura hierárquica automaticamente. O primeiro passo, comum a todas as três implementações discutidas aqui, é encontrar uma interface “mínima” para Adaptee, ou seja, o menor subconjunto de operações que permite fazer a adaptação. Uma interface mínima, consistindo em somente um par de operações, é mais fácil de adaptar que uma interface com dúzias de operações. Para o TreeDisplay, o adaptee é qualquer estrutura hierárquica. Uma interface minimalista pode incluir duas operações, uma que define como apresentar graficamente um nó na estrutura hierárquica e outra que recupera os filhos do nó. A interface mínima conduz a três abordagens de implementação:</li></ol><p>(a) Utilizando operações abstratas. Defina na classe TreeDisplay operações abstratas correspondentes à interface mínima de Adaptee. As operações abstratas devem ser implementadas por subclasses que também adaptam o objeto hierarquicamente estruturado. Por exemplo, uma subclasse DirectoryTreeDisplay implementará essas operações acessando a estrutura do diretório.</p><figure><img src="https://github.com/user-attachments/assets/948d94dd-ec86-4e6e-a33c-40165d114503" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>DirectoryTreeDisplay especializa a interface mínima de maneira que possa exibir estruturas de diretório compostas de objetos FileSystemEntity.</p><p>(b) Utilizando objetos delegados. Nesta abordagem, o TreeDisplay repassa solicitações de acesso à estrutura hierárquica para um objeto delegado. O TreeDisplay pode usar uma estratégia de adaptação diferente pela substituição de um delegado por outro. Por exemplo, suponha que exista um DirectoryBrowser que usa um TreeDisplay. Directory Browser pode vir a ser um bom delegado para adaptar TreeDisplay à estrutura do diretório hierárquico. Em linguagens com tipos definidos dinamicamente, como Smalltalk ou Objective C, essa abordagem somente exige uma interface para registrar o delegado junto ao adapter. Então, o TreeDisplay simplesmente repassa as solicitações para o delegado. NEXTSTEP [Add94] usa essa abordagem intensamente para reduzir o uso de subclasses. As linguagens com tipos estaticamente definidos, como C++, requerem uma definição explícita da interface para o delegado. Podemos especificar tal interface colocando a interface mínima requerida por TreeDisplay em uma classe abstrata TreeAccessorDelegate. Então, podemos misturar essa interface com o delegado de nossa escolha – DirectoryBrowser, neste caso – usando herança. Usamos herança simples se o DirectoryBrowse não tiver classe-mãe, caso contrário, usamos herança múltipla. Misturar classes dessa maneira é mais fácil do que introduzir uma nova subclasse TreeDisplay e implementar suas operações individualmente.</p><figure><img src="https://github.com/user-attachments/assets/a58d043b-4180-4995-b902-583717ef9025" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>(c) Adapters parametrizados.</p><p>A maneira usual de suportar adaptadores conectáveis em Smalltalk é parametrizar um adaptador com um ou mais blocos (Smalltalk). A primitiva “block” suporta a adaptação sem usar subclasses. Um bloco pode adaptar uma solicitação e o adaptador pode armazenar um bloco para cada solicitação individual. No nosso exemplo, isso significa que TreeDisplay armazena um bloco para converter um nó em um GraphicNode e outro bloco para acessar os filhos de um nó. Por exemplo, para criar um TreeDisplay em uma hierarquia de diretório, escrevemos</p><figure><img src="https://github.com/user-attachments/assets/0d69bf55-bbe3-473b-a8d9-84f8cd7572b6" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>Se você está construindo uma adaptação de interface em uma classe, essa abordagem oferece uma alternativa conveniente ao uso de subclasses.</p><h2 id="exemplo-de-codigo" tabindex="-1"><a class="header-anchor" href="#exemplo-de-codigo"><span>Exemplo de código</span></a></h2><p>Apresentaremos um breve esboço da implementação de adaptadores de classes e de objetos para o exemplo apresentado na seção Motivação, começando com as classes Shape e TextView.</p><figure><img src="https://github.com/user-attachments/assets/c09e9d4e-8550-40a6-a669-0aca05ca82c2" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>Shape supõe uma caixa delimitadora definida pelos seus cantos opostos. Em contraste, TextView é definido por origem, altura e largura. Shape também define uma operação CreateManipulator para criar um objeto Manipulator, o qual sabe como animar uma forma quando um usuário a manipula.1 O TextView não tem uma operação equivalente. A classe TextShape é um adaptador entre essas diferentes interfaces.</p><p>Um adaptador de classe utiliza a herança múltipla para adaptar interfaces. O ponto-chave dos adaptadores de classe é a utilização de um ramo de herança para herdar a interface e de outro ramo para herdar a implementação. A maneira usual de fazer essa distinção em C++ é herdar a interface publicamente e herdar a implementação privadamente. Usaremos essa convenção para definir o adaptador TextShape.</p><p>A operação BoundingBox converte a interface de TextView para que esta fique de acordo com a interface de Shape.</p><figure><img src="https://github.com/user-attachments/assets/8a2f00bd-9fcb-40b6-adc9-add084a6e771" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>A operação IsEmpty demonstra o repasse direto de solicitações, comum em implementações de adaptadores:</p><figure><img src="https://github.com/user-attachments/assets/5b66ca13-4f3e-4b88-81ef-e0d06bee2478" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>Finalmente, definimos CreateManipulator (a qual não é suportada por TextView) a partir do zero. Assumimos que já implementamos uma classe TextManipulator que suporta manipulação de um TextShape.</p><figure><img src="https://github.com/user-attachments/assets/2da46f83-f4d7-4c47-b3d0-ee75468e331b" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>O adaptador de objeto utiliza composição de objetos para combinar classes que têm interfaces diferentes. Nesta abordagem, o adaptador TextShape mantém um apontador para TextView.</p><figure><img src="https://github.com/user-attachments/assets/f711c5a9-ee23-4a67-809f-dba2648057c9" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>TextShape deve iniciar o apontador para instância de TextView, e ele faz isso no constructor. Ele também deve invocar operações no seu objeto TextView sempre que suas próprias operações forem invocadas. Neste exemplo, presuma que o cliente crie o objeto TextView e o passe para o constructor de TextShape:</p><figure><img src="https://github.com/user-attachments/assets/15744c1f-ef1b-4a59-bdba-cab9b6584d3f" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>A implementação de CreateManipulator não muda em relação à versão para o adaptador de classe, uma vez que é implementada do zero e não reutiliza qualquer funcionalidade existente de TextView.</p><figure><img src="https://github.com/user-attachments/assets/5dc6f9d8-3f8d-403d-8d74-ca72c0c9f2a9" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>Compare este código com o código do caso do adaptador de classe. O adaptador de objeto exige um pouco mais de esforço para escrever, porém, é mais flexível. Por exemplo, a versão do adaptador de objeto de TextShape funcionará igualmente bem com subclasses de TextView – o cliente simplesmente passa uma instância de uma subclasse de TextView para o constructor de TextShape.</p><h2 id="usos-conhecidos" tabindex="-1"><a class="header-anchor" href="#usos-conhecidos"><span>Usos conhecidos</span></a></h2><p>O exemplo da seção Motivação vem do ET++Draw, uma aplicação de desenho baseada na ET++ [WGM88]. O ET++Draw reutiliza as classes para edição de texto da ET++ usando um adapter de classe TextShape. O InterViews 2.6 define uma classe abstrata Interactor para elementos da interface do usuário, tais como barras de rolamento, botões e menus [VL88]. Ele também define uma classe abstrata Graphic para objetos gráficos estruturados, tais como linhas, círculos, polígonos e “splines”. Tanto Interactors como Graphics têm aparências gráficas, porém, diferentes interfaces e implementações (eles não têm uma classe ancestral compartilhada) e são, portanto, incompatíveis – você não pode incluir diretamente um objeto gráfico estruturado em, por exemplo, uma caixa de diálogo.</p><p>Em vez disso, o InterViews 2.6 define um adaptador de objeto chamado GraphicBlock, uma subclasse de Interactor que contém uma instância de Graphic. O GraphicBlock adapta a interface da classe Graphic àquela de Interactor. O GraphicBlock permite que uma instância de Graphic seja exibida, rolada e possa sofrer zooms dentro de uma estrutura Interactor. Os adaptadores conectáveis são comuns em ObjectWorks\\Smalltalk. O Smalltalk-padrão define uma classe ValueModel para visões (views) que exibem um único valor. ValueModel define uma interface value, value: para acessar o valor. Estes são métodos abstratos. Programadores de aplicação acessam o valor usando nomes mais específicos do domínio, tais como width e width:, mas eles não deveriam ter que criar subclasses de ValueModel para adaptar tais nomes específicos da aplicação à interface de ValueModel.</p><p>Em vez disso, ObjectWorks\\Smalltalk inclui uma subclasse de ValueModel chamada PluggableAdaptor. Um objeto PluggableAdaptor adapta outros objetos à interface de ValueModel (value, value:). Ela pode ser parametrizada com blocos para obter e atualizar (set) o valor desejado. PluggableAdaptor utiliza internamente estes blocos para implementar a interface value, value:. PluggableAdaptor também permite passar nomes no Selector (por exemplo, width, width:) diretamente por conveniência sintática. Ela converte estes seletores (selectors) nos blocos correspondentes, de forma automática.</p><figure><img src="https://github.com/user-attachments/assets/b1dea922-efc0-4b40-9709-927e42e1fc75" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>Outro exemplo proveniente de ObjectWorks\\Smalltalk é a classe TableAdaptor. Uma TableAdaptor pode adaptar uma seqüência de objetos numa apresentação tabular. A tabela exibe um objeto por linha. O cliente parametriza TableAdaptor com um conjunto de mensagens que uma tabela pode usar para obter os valores de coluna de um objeto.</p><p>Algumas classes no AppKit do NeXT [Add94] usam objetos delegados para executar adaptação de interfaces. Um exemplo é a classe NXBrowser que pode exibir listas hierárquicas de dados. NXBrowser usa um objeto delegado para acessar e adaptar dados. O “Casamento de Conveniência” (“Marriage of Convenience”), [Mey88] de Meyer é uma forma de um adaptador de classe. Meyer descreve como uma classe FixedStack adapta a implementação de uma classe Array à interface de uma classe stack. O resultado é uma pilha (Stack) que contém um número fixo de entradas.</p><h2 id="padroes-relacionados" tabindex="-1"><a class="header-anchor" href="#padroes-relacionados"><span>Padrões relacionados</span></a></h2><p>O padrão Bridge(151) tem uma estrutura similar a um adaptador de objeto, porém, Bridge tem uma intenção diferente: tem por objetivo separar uma interface da sua implementação, de modo que elas possam variar fácil e independentemente. Um adaptador se destina a mudar a interface de um objeto existente.</p><p>O padrão Decorator (170) aumenta outro objeto sem mudar sua interface. Desta forma, um Decorator é mais transparente para a aplicação do que um adaptador.</p><p>Como conseqüência, Decorator suporta a composição recursiva, a qual não é possível com adaptadores puros.</p><p>O Proxy (198) define um representante ou “procurador”para outro objeto e nãomuda a sua interface.</p><h2 id="meu-exemplo" tabindex="-1"><a class="header-anchor" href="#meu-exemplo"><span>Meu exemplo</span></a></h2><h3 id="cenario" tabindex="-1"><a class="header-anchor" href="#cenario"><span>Cenário</span></a></h3><p>Você tem um sistema de carga de veículos elétricos que precisa lidar com diferentes tipos de conectores de carga, como o Tipo 1 e o Tipo 2. O sistema deve oferecer uma interface uniforme para carregar o veículo, independentemente do tipo de conector.</p><figure><img src="https://github.com/user-attachments/assets/e469e10f-3f20-4e60-aa56-2eb06fbac15e" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><h3 id="descricao-dos-componentes" tabindex="-1"><a class="header-anchor" href="#descricao-dos-componentes"><span>Descrição dos Componentes:</span></a></h3><ol><li>SistemaDeCarga: Classe que precisa carregar o veículo elétrico e interage com a interface Conector.</li><li>Conector: Interface que define o método conectar(), que o SistemaDeCarga espera.</li><li>AdaptadorTipo1: Classe que adapta o conector Tipo 1 para a interface Conector. Implementa o método conectar() usando uma instância de ConectorTipo1.</li><li>AdaptadorTipo2: Classe que adapta o conector Tipo 2 para a interface Conector. Implementa o método conectar() usando uma instância de ConectorTipo2.</li><li>ConectorTipo1: Classe que representa um conector de tipo 1 com o método conectarTipo1().</li><li>ConectorTipo2: Classe que representa um conector de tipo 2 com o método conectarTipo2().</li></ol><h2 id="referencia" tabindex="-1"><a class="header-anchor" href="#referencia"><span>Referência</span></a></h2><ol><li>AMMA, Erich. et al. Padrões de projetos: Soluções reutilizáveis de software orientados a objetos Bookman editora, 2009.</li></ol>',85)]))}const p=a(r,[["render",i],["__file","index.html.vue"]]),m=JSON.parse('{"path":"/includes/seminario-2-SalvadorCerqueiraJr/","title":"Adapter","lang":"pt-BR","frontmatter":{"description":"Adapter O Adapter é um padrão de projeto estrutural que permite objetos com interfaces incompatíveis colaborarem entre si. Intenção Converter a interface de uma classe em outra ...","head":[["meta",{"property":"og:url","content":"https://20241-ifba-saj-ads-ppr.github.io/blog-material-aula/blog-material-aula/includes/seminario-2-SalvadorCerqueiraJr/"}],["meta",{"property":"og:site_name","content":"20241 PPR Blog das Aulas"}],["meta",{"property":"og:title","content":"Adapter"}],["meta",{"property":"og:description","content":"Adapter O Adapter é um padrão de projeto estrutural que permite objetos com interfaces incompatíveis colaborarem entre si. Intenção Converter a interface de uma classe em outra ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://github.com/user-attachments/assets/cb39c6fa-5ebb-4f6f-91af-891bd4a05f54"}],["meta",{"property":"og:locale","content":"pt-BR"}],["meta",{"property":"article:author","content":"Leandro Souza"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Adapter\\",\\"image\\":[\\"https://github.com/user-attachments/assets/cb39c6fa-5ebb-4f6f-91af-891bd4a05f54\\",\\"https://github.com/user-attachments/assets/2e8051f5-8b9d-4687-b54f-85e2b924e65b\\",\\"https://github.com/user-attachments/assets/2943d0e9-5bd0-420f-9547-a7815c0d2836\\",\\"https://github.com/user-attachments/assets/fcba4481-44b9-4d12-ba7a-51815367538e\\",\\"https://github.com/user-attachments/assets/948d94dd-ec86-4e6e-a33c-40165d114503\\",\\"https://github.com/user-attachments/assets/a58d043b-4180-4995-b902-583717ef9025\\",\\"https://github.com/user-attachments/assets/0d69bf55-bbe3-473b-a8d9-84f8cd7572b6\\",\\"https://github.com/user-attachments/assets/c09e9d4e-8550-40a6-a669-0aca05ca82c2\\",\\"https://github.com/user-attachments/assets/8a2f00bd-9fcb-40b6-adc9-add084a6e771\\",\\"https://github.com/user-attachments/assets/5b66ca13-4f3e-4b88-81ef-e0d06bee2478\\",\\"https://github.com/user-attachments/assets/2da46f83-f4d7-4c47-b3d0-ee75468e331b\\",\\"https://github.com/user-attachments/assets/f711c5a9-ee23-4a67-809f-dba2648057c9\\",\\"https://github.com/user-attachments/assets/15744c1f-ef1b-4a59-bdba-cab9b6584d3f\\",\\"https://github.com/user-attachments/assets/5dc6f9d8-3f8d-403d-8d74-ca72c0c9f2a9\\",\\"https://github.com/user-attachments/assets/b1dea922-efc0-4b40-9709-927e42e1fc75\\",\\"https://github.com/user-attachments/assets/e469e10f-3f20-4e60-aa56-2eb06fbac15e\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Leandro Souza\\",\\"url\\":\\"https://github.com/leandro-costa\\"}]}"]]},"headers":[{"level":2,"title":"Intenção","slug":"intencao","link":"#intencao","children":[]},{"level":2,"title":"Também conhecido como","slug":"tambem-conhecido-como","link":"#tambem-conhecido-como","children":[]},{"level":2,"title":"Motivação","slug":"motivacao","link":"#motivacao","children":[]},{"level":2,"title":"Aplicabilidade","slug":"aplicabilidade","link":"#aplicabilidade","children":[]},{"level":2,"title":"Estrutura","slug":"estrutura","link":"#estrutura","children":[]},{"level":2,"title":"Participantes","slug":"participantes","link":"#participantes","children":[]},{"level":2,"title":"Colaborações","slug":"colaboracoes","link":"#colaboracoes","children":[]},{"level":2,"title":"Conseqüências","slug":"consequencias","link":"#consequencias","children":[]},{"level":2,"title":"Implementação","slug":"implementacao","link":"#implementacao","children":[]},{"level":2,"title":"Exemplo de código","slug":"exemplo-de-codigo","link":"#exemplo-de-codigo","children":[]},{"level":2,"title":"Usos conhecidos","slug":"usos-conhecidos","link":"#usos-conhecidos","children":[]},{"level":2,"title":"Padrões relacionados","slug":"padroes-relacionados","link":"#padroes-relacionados","children":[]},{"level":2,"title":"Meu exemplo","slug":"meu-exemplo","link":"#meu-exemplo","children":[{"level":3,"title":"Cenário","slug":"cenario","link":"#cenario","children":[]},{"level":3,"title":"Descrição dos Componentes:","slug":"descricao-dos-componentes","link":"#descricao-dos-componentes","children":[]}]},{"level":2,"title":"Referência","slug":"referencia","link":"#referencia","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":11.01,"words":3304},"filePathRelative":"includes/seminario-2-SalvadorCerqueiraJr/README.md","autoDesc":true}');export{p as comp,m as data};
