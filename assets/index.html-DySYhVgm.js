import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as l,o as d,c,a as n,e as a,b as o,d as r}from"./app-D1DVgmHE.js";const u={},p={href:"https://mermaid.js.org/syntax/classDiagram.html",target:"_blank",rel:"noopener noreferrer"},m={href:"https://docs.github.com/pt/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax",target:"_blank",rel:"noopener noreferrer"};function b(v,e){const i=l("Mermaid"),s=l("ExternalLinkIcon");return d(),c("div",null,[e[2]||(e[2]=n('<h1 id="object-pool" tabindex="-1"><a class="header-anchor" href="#object-pool"><span>Object Pool</span></a></h1><h2 id="intencao" tabindex="-1"><a class="header-anchor" href="#intencao"><span>Intenção</span></a></h2><p>O pool de objetos pode oferecer um aumento significativo no desempenho; ele é mais eficaz em situações em que o custo de inicialização de uma instância de classe é alto, a taxa de instanciação de uma classe é alta e o número de instanciações em uso a qualquer momento é baixo.</p><h2 id="o-que-e-um-object-pool-design-pattern" tabindex="-1"><a class="header-anchor" href="#o-que-e-um-object-pool-design-pattern"><span>O que é um Object Pool Design Pattern?</span></a></h2><p>O padrão de design Object Pool é um padrão de criação que gerencia um pool de objetos reutilizáveis, reduzindo assim a sobrecarga de criação e destruição de objetos. Neste padrão, um pool de objetos é criado e mantido, e os clientes podem pegar objetos emprestados do pool quando precisarem e devolvê-los ao pool quando terminarem</p><p>Um pool de objetos é um contêiner que contém uma certa quantidade de objetos. Então, quando um objeto é retirado do pool, ele não fica disponível no pool até ser colocado de volta.</p><h2 id="problema" tabindex="-1"><a class="header-anchor" href="#problema"><span>Problema</span></a></h2><p>Os pools de objetos (também conhecidos como pools de recursos) são usados ​​para gerenciar o cache de objetos. Um cliente com acesso a um pool de objetos pode evitar a criação de novos objetos simplesmente solicitando ao pool um que já tenha sido instanciado. Geralmente, o pool será um pool crescente, ou seja, o próprio pool criará novos objetos se o pool estiver vazio, ou podemos ter um pool, o que restringe o número de objetos criados.</p><p>É desejável manter todos os objetos Reusable que não estão em uso no momento no mesmo pool de objetos para que eles possam ser gerenciados por uma política coerente. Para conseguir isso, a classe Reusable Pool é projetada para ser uma classe singleton.</p><h2 id="discussao" tabindex="-1"><a class="header-anchor" href="#discussao"><span>Discussão</span></a></h2><p>O Object Pool permite que outros &quot;retirem&quot; objetos do seu pool. Quando esses objetos não são mais necessários para seus processos, eles são retornados ao pool para serem reutilizados.</p><p>No entanto, não queremos que um processo tenha que esperar que um objeto específico seja liberado, então o Object Pool também instancia novos objetos conforme necessário, mas também deve implementar um recurso para limpar objetos não utilizados periodicamente.</p><h2 id="ciclo-de-vida-do-pool-de-objetos" tabindex="-1"><a class="header-anchor" href="#ciclo-de-vida-do-pool-de-objetos"><span>Ciclo de vida do pool de objetos</span></a></h2><p>O ciclo de vida dos objetos em um pool de objetos envolve os seguintes estágios:</p><ul><li>Etapa 1: Criação : Os objetos são inicialmente criados e adicionados ao pool.</li><li>Etapa 2: Empréstimo : os clientes solicitam e tomam emprestados objetos do pool.</li><li>Etapa 3: Uso : Os clientes usam os objetos emprestados para suas tarefas.</li><li>Etapa 4: Devolução : Após o uso, os clientes devolvem os objetos ao pool para reutilização.</li><li>Etapa 5: Rejeição ou Destruição : Se o pool estiver cheio ou os objetos não forem usados, eles podem ser rejeitados ou removidos do pool.</li></ul><h2 id="estrutura" tabindex="-1"><a class="header-anchor" href="#estrutura"><span>Estrutura</span></a></h2><figure><img src="https://github.com/user-attachments/assets/576ef42b-bc82-4f05-9b40-39d50e9ab6f6" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><ul><li>Cliente: Esta é a classe que utiliza um objeto do tipo PooledObject.</li><li>ReuseablePool: a classe PooledObject é o tipo que é caro ou lento para instanciar ou que tem disponibilidade limitada, portanto, deve ser mantida no pool de objetos.</li><li>ObjectPool: a classe Pool é a classe mais importante no padrão de design do pool de objetos. ObjectPool mantém uma lista de objetos disponíveis e uma coleção de objetos que já foram solicitados do pool.</li></ul><h2 id="quando-usar-o-padrao-de-design-de-pool-de-objetos" tabindex="-1"><a class="header-anchor" href="#quando-usar-o-padrao-de-design-de-pool-de-objetos"><span>Quando usar o padrão de design de pool de objetos?</span></a></h2><p>Veja abaixo quando usar o padrão de design de pool de objetos:</p><ul><li>Criação de Objetos Caros : Se a criação de instâncias de objetos exige muitos recursos, como estabelecer conexões de banco de dados, conexões de rede ou criar objetos pesados, o pooling pode ser benéfico. O pooling permite que você crie esses objetos caros uma vez e os reutilize várias vezes.</li><li>Disponibilidade limitada de recursos : quando há disponibilidade limitada de recursos, como um número limitado de conexões de banco de dados, o pool ajuda a gerenciar esses recursos de forma eficiente, reutilizando-os em vez de criar novos além do limite.</li><li>Redução de Overhead : O overhead de criação e destruição de objetos pode ser significativo em certos aplicativos. Ao reutilizar objetos do pool, você pode reduzir o overhead associado à criação e destruição de objetos com frequência.</li><li>Melhoria do desempenho : o pool pode levar à melhoria do desempenho, evitando a sobrecarga de criação e destruição de objetos e reduzindo a contenção por recursos limitados.</li></ul><h2 id="quando-nao-usar-o-padrao-de-design-de-pool-de-objetos" tabindex="-1"><a class="header-anchor" href="#quando-nao-usar-o-padrao-de-design-de-pool-de-objetos"><span>Quando não usar o padrão de design de pool de objetos?</span></a></h2><p>Veja abaixo quando não usar o padrão de design de pool de objetos:</p><ul><li>Objetos leves : se os objetos forem leves para criar e destruir, e a sobrecarga da criação de objetos for insignificante, usar um pool de objetos pode introduzir complexidade desnecessária sem benefícios significativos.</li><li>Sem escassez de recursos : se o sistema tiver recursos abundantes disponíveis e não houver risco de exaustão de recursos, implementar um pool de objetos pode não ser necessário e pode adicionar complexidade desnecessária.</li><li>Padrões de uso imprevisíveis : se o padrão de uso de objetos for altamente imprevisível, de modo que os objetos raramente sejam reutilizados ou o tamanho do pool não possa ser estimado de forma eficaz, implementar um pool de objetos pode não ser benéfico.</li><li>Sobrecarga de manutenção : pools de objetos introduzem complexidade adicional para gerenciar o ciclo de vida de objetos, como lidar com a criação, validação e destruição de objetos. Se a sobrecarga de manutenção superar os benefícios obtidos com o pooling, pode não valer a pena implementar.</li></ul><h2 id="exemplo-01" tabindex="-1"><a class="header-anchor" href="#exemplo-01"><span>Exemplo 01</span></a></h2><p>O padrão de pool de objetos é semelhante a um depósito de escritório. Quando um novo funcionário é contratado, a gerente do escritório tem que preparar um espaço de trabalho para ele. Ela descobre se há ou não um equipamento extra no depósito do escritório. Se houver, ela o usa. Se não, ela faz um pedido para comprar um novo equipamento da Amazon. Caso um funcionário seja demitido, seu equipamento é movido para o depósito, de onde pode ser levado quando um novo local de trabalho for necessário.</p><figure><img src="https://github.com/user-attachments/assets/04f7d1f3-2c00-4727-a1ce-a6c04f83f315" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><h4 id="lista-de-controle" tabindex="-1"><a class="header-anchor" href="#lista-de-controle"><span>Lista de controle</span></a></h4><ol><li>Crie ObjectPooluma classe com uma matriz privada de Objects dentro</li><li>Crie acquiree releasemétodos na classe ObjectPool</li><li>Certifique-se de que seu ObjectPool é Singleton</li></ol><h4 id="regras-de-ouro" tabindex="-1"><a class="header-anchor" href="#regras-de-ouro"><span>Regras de ouro</span></a></h4><ul><li>O padrão Factory Method pode ser usado para encapsular a lógica de criação de objetos. No entanto, ele não os gerencia após sua criação, o padrão object pool mantém o controle dos objetos que ele cria.</li><li>Os pools de objetos geralmente são implementados como singletons.</li></ul><h2 id="exemplo-02" tabindex="-1"><a class="header-anchor" href="#exemplo-02"><span>Exemplo 02</span></a></h2><p>Uma analogia do mundo real para o padrão de design Object Pool poderia ser uma biblioteca ou uma livraria.</p><ol><li>Inventário de livros :</li></ol><ul><li>Pense na coleção da biblioteca ou no inventário da livraria como um conjunto de objetos.</li><li>Cada livro representa um objeto que pode ser emprestado ou usado.</li></ul><ol start="2"><li>Empréstimo de livros :</li></ol><ul><li>Quando um usuário da biblioteca ou um cliente da livraria deseja pegar um livro emprestado, ele procura o bibliotecário ou o balconista da loja.</li><li>Da mesma forma, no software, quando um componente precisa de um objeto, ele o solicita do pool de objetos.</li></ul><ol start="3"><li>Livros disponíveis :</li></ol><ul><li>A biblioteca ou livraria mantém um registro dos livros disponíveis que ainda não foram emprestados.</li><li>Esses livros estão prontos para serem emprestados. Similarmente, no pool de objetos, há objetos que estão disponíveis para uso.</li></ul><ol start="4"><li>Processo de empréstimo :</li></ol><ul><li>Quando um cliente ou cliente deseja pegar um livro emprestado, ele o retira do acervo disponível.</li><li>Essa ação é análoga a um componente que pega um objeto do pool de objetos.</li></ul><ol start="5"><li>Devolução de livros :</li></ol><ul><li>Após ler ou usar o livro, o usuário ou cliente o devolve à biblioteca ou livraria.</li><li>Da mesma forma, no software, quando um componente termina de usar um objeto, ele o retorna ao pool de objetos.</li></ul><ol start="6"><li>Condição do livro :</li></ol><ul><li>A biblioteca ou livraria verifica regularmente as condições dos livros, repara quaisquer danos e retira de circulação quaisquer livros em mau estado.</li><li>Esse processo de manutenção é semelhante aos procedimentos de validação e limpeza executados em objetos no pool de objetos.</li></ul><ol start="7"><li>Estoque máximo de livros :</li></ol><ul><li>Tanto a biblioteca quanto a livraria têm um limite máximo para o número de livros que podem manter devido a restrições de espaço ou limitações orçamentárias.</li><li>Da mesma forma, em software, os pools de objetos geralmente têm um tamanho máximo para evitar o esgotamento de recursos.</li></ul>',47)),a(i,{id:"mermaid-331",code:"eJxtj0sKwjAQhvc9xSyVkgsUV6I7caMeYAwhDOQhyVQU9e7mIba1zi75v28eQoiGiY3qYHtT9mI8rOlsyLOS2ORUGoxxQ6gD2gZSDXkgD6unEHCKfX6MzAzu6Bo+wMT5Def2nzkdtBgC3oFcZHSS6owJlBiteLGsfll83vxRwlztgQM5DXtvVfl8jcWy4AB/6SNxb+oNiX8DW2VivA=="}),e[3]||(e[3]=o("h2",{id:"exemplo-03",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#exemplo-03"},[o("span",null,"Exemplo 03")])],-1)),a(i,{id:"mermaid-335",code:"eJxtjzEOwjAMRfecwsoERR1YK8QCIwNXsNKospQmEBcWxN1xAqIG1VPk977tuIDMR8Ih42hAqjbgkGL0bqIUzykFeFRUagMn4mk38z1cxFAc3fVG2c/Gat2pecrMPnhkbTp5almS90R9zTzN4n0/t5W8tMvGb+5NeuIl+Bn69127tdC0LdjG6k0djBhx8GzMCwvtXIU="}),e[4]||(e[4]=n(`<p>Descrição</p><ol><li><p><strong>ConnectionPool</strong>:</p><ul><li><strong>Atributos</strong>: <ul><li><code>pool</code>: Uma lista de conexões de banco de dados disponíveis para reutilização.</li></ul></li><li><strong>Métodos</strong>: <ul><li><code>acquireConnection()</code>: Adquire uma conexão do pool, retornando uma conexão disponível ou criando uma nova se necessário.</li><li><code>releaseConnection(conn)</code>: Libera uma conexão de volta para o pool, permitindo sua reutilização futura.</li></ul></li></ul></li><li><p><strong>Connection</strong>:</p><ul><li><strong>Métodos</strong>: <ul><li><code>connect()</code>: Estabelece uma conexão com o banco de dados.</li><li><code>disconnect()</code>: Fecha a conexão com o banco de dados.</li></ul></li></ul></li><li><p><strong>Relação</strong>:</p><ul><li>O <code>ConnectionPool</code> gerencia múltiplas instâncias de <code>Connection</code>, representado por uma relação de &quot;um para muitos&quot;.</li></ul></li></ol><h3 id="exemplo-04" tabindex="-1"><a class="header-anchor" href="#exemplo-04"><span>Exemplo 04</span></a></h3><ul><li><strong>Pool de Conexões de Banco de Dados</strong>: Imagine um sistema que precisa fazer muitas conexões com um banco de dados. Criar e destruir conexões repetidamente pode ser caro em termos de tempo e recursos. O pool de conexões mantém um número fixo de conexões abertas e as reutiliza. Quando um cliente precisa de uma conexão, ele a adquire do pool. Quando termina de usá-la, a conexão é liberada de volta ao pool, tornando-se disponível para outros clientes.</li></ul><p>Esse exemplo ilustra como o padrão Object Pool pode ser aplicado na prática para gerenciar recursos limitados e melhorar a eficiência.</p><h2 id="exemplo-pratico-livro-k19" tabindex="-1"><a class="header-anchor" href="#exemplo-pratico-livro-k19"><span>Exemplo prático - Livro K19</span></a></h2><p>Estamos desenvolvendo um sistema para uma empresa com uma quantidade muito grande de projetos. Esse sistema deve controlar os recursos utilizados nos projetos. De maneira genérica, um recurso pode ser um funcionário, uma sala, um computador, um carro, etc.</p><p>Podemos implementar classes especializadas no controle de cada tipo de recurso utilizado nos projetos. Além disso, seria interessante padronizar essas classes através de uma interface.</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>1 public interface Pool &lt;T &gt; {
2 T acquire () ;
3 void release ( T t ) ;
4 }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Código Java 2.69: Pool.java</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>1 public class FuncionarioPool implements Pool &lt; Funcionario &gt; {
2 private Collection &lt; Funcionario &gt; funcionarios ;
3
4 public FuncionarioPool () {
5 // iniciliaza a coleção de funcionários
6 }
7
8 public Funcionario acquire () {
9 // escolhe um funcionário da coleção
10 }
11
12 public void release ( Funcionario f ) {
13 // adiciona o funcionário na coleção
14 }
15 }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Código Java 2.70: FuncionarioPool.java</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>1 public class SalaPool implements Pool &lt; Sala &gt; {
2 private Collection &lt; Sala &gt; salas ;
3
4 public SalaPool () {
5 // iniciliaza a coleção de salas
6 }
7
8 public Sala acquire () {
9 // escolhe uma sala da coleção
10 }
11
12 public void release ( Sala sala ) {
13 // adiciona a sala na coleção
14 }
15 }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Código Java 2.71: SalaPool.java</p><p>Agora, quando um projeto necessita de um recurso como funcionários ou salas basta utilizar os pools.</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>1 Pool &lt; Sala &gt; poolSalas = ...
2 Pool &lt; Funcionario &gt; poolFuncionario = ...
3
4 // obtendo os recursos
5 Sala sala = poolSalas . acquire () ;
6 Funcionario funcionario = poolFuncionario . acquire () ;
7
8 // usando os recursos
9 ...
10
11 // liberando os recursos
12 poolSalas . release ( sala ) ;
13 poolFuncionarios . release ( funcionario )
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Código Java 2.72: interagindo com um pool</p><h3 id="organizacao" tabindex="-1"><a class="header-anchor" href="#organizacao"><span>Organização</span></a></h3><p>O diagrama UML abaixo ilustra a organização desse padrão.</p><figure><img src="https://github.com/user-attachments/assets/f9a0c4a0-c7e6-4d94-a029-0aeefc4c8760" alt="UML" tabindex="0" loading="lazy"><figcaption>UML</figcaption></figure><p>Os personagens desse padrão são:</p><p><strong>Product</strong> (Funcionario, Sala) Define os objetos gerenciados pelos Pools. <strong>Pool</strong> (Pool) Interface dos objetos que controlam a aquisição e a liberação dos Products. <strong>ConcretePool</strong> (SalaPool, FuncionarioPool) Implementação particular de um Pool que gerencia um Product específico.</p><h2 id="referencias" tabindex="-1"><a class="header-anchor" href="#referencias"><span>Referências</span></a></h2><ol><li>K19. Design Patterns em Java.</li><li>https://www.geeksforgeeks.org/object-pool-design-pattern/</li><li>https://sourcemaking.com/design_patterns/object_pool</li><li>https://acervolima.com/padrao-de-design-de-pool-de-objetos/</li></ol>`,24)),o("p",null,[o("a",p,[e[0]||(e[0]=r("Mermaid Class Diagram.html")),a(s)])]),o("p",null,[o("a",m,[e[1]||(e[1]=r("Markdown")),a(s)])])])}const j=t(u,[["render",b],["__file","index.html.vue"]]),f=JSON.parse('{"path":"/includes/seminario-1-SalvadorCerqueiraJr/","title":"Object Pool","lang":"pt-BR","frontmatter":{"description":"Object Pool Intenção O pool de objetos pode oferecer um aumento significativo no desempenho; ele é mais eficaz em situações em que o custo de inicialização de uma instância de c...","head":[["meta",{"property":"og:url","content":"https://20241-ifba-saj-ads-ppr.github.io/blog-material-aula/blog-material-aula/includes/seminario-1-SalvadorCerqueiraJr/"}],["meta",{"property":"og:site_name","content":"20241 PPR Blog das Aulas"}],["meta",{"property":"og:title","content":"Object Pool"}],["meta",{"property":"og:description","content":"Object Pool Intenção O pool de objetos pode oferecer um aumento significativo no desempenho; ele é mais eficaz em situações em que o custo de inicialização de uma instância de c..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://github.com/user-attachments/assets/576ef42b-bc82-4f05-9b40-39d50e9ab6f6"}],["meta",{"property":"og:locale","content":"pt-BR"}],["meta",{"property":"article:author","content":"Leandro Souza"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Object Pool\\",\\"image\\":[\\"https://github.com/user-attachments/assets/576ef42b-bc82-4f05-9b40-39d50e9ab6f6\\",\\"https://github.com/user-attachments/assets/04f7d1f3-2c00-4727-a1ce-a6c04f83f315\\",\\"https://github.com/user-attachments/assets/f9a0c4a0-c7e6-4d94-a029-0aeefc4c8760\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Leandro Souza\\",\\"url\\":\\"https://github.com/leandro-costa\\"}]}"]]},"headers":[{"level":2,"title":"Intenção","slug":"intencao","link":"#intencao","children":[]},{"level":2,"title":"O que é um Object Pool Design Pattern?","slug":"o-que-e-um-object-pool-design-pattern","link":"#o-que-e-um-object-pool-design-pattern","children":[]},{"level":2,"title":"Problema","slug":"problema","link":"#problema","children":[]},{"level":2,"title":"Discussão","slug":"discussao","link":"#discussao","children":[]},{"level":2,"title":"Ciclo de vida do pool de objetos","slug":"ciclo-de-vida-do-pool-de-objetos","link":"#ciclo-de-vida-do-pool-de-objetos","children":[]},{"level":2,"title":"Estrutura","slug":"estrutura","link":"#estrutura","children":[]},{"level":2,"title":"Quando usar o padrão de design de pool de objetos?","slug":"quando-usar-o-padrao-de-design-de-pool-de-objetos","link":"#quando-usar-o-padrao-de-design-de-pool-de-objetos","children":[]},{"level":2,"title":"Quando não usar o padrão de design de pool de objetos?","slug":"quando-nao-usar-o-padrao-de-design-de-pool-de-objetos","link":"#quando-nao-usar-o-padrao-de-design-de-pool-de-objetos","children":[]},{"level":2,"title":"Exemplo 01","slug":"exemplo-01","link":"#exemplo-01","children":[]},{"level":2,"title":"Exemplo 02","slug":"exemplo-02","link":"#exemplo-02","children":[]},{"level":2,"title":"Exemplo 03","slug":"exemplo-03","link":"#exemplo-03","children":[{"level":3,"title":"Exemplo 04","slug":"exemplo-04","link":"#exemplo-04","children":[]}]},{"level":2,"title":"Exemplo prático - Livro K19","slug":"exemplo-pratico-livro-k19","link":"#exemplo-pratico-livro-k19","children":[{"level":3,"title":"Organização","slug":"organizacao","link":"#organizacao","children":[]}]},{"level":2,"title":"Referências","slug":"referencias","link":"#referencias","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":6.57,"words":1971},"filePathRelative":"includes/seminario-1-SalvadorCerqueiraJr/README.md","autoDesc":true}');export{j as comp,f as data};
