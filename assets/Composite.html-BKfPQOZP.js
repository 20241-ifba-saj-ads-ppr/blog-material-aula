import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,b as a,d as t,e as r,a as n,o as l,r as p}from"./app-BrOvOMMH.js";const m={},d={href:"https://github.com/gabrielflb",target:"_blank",rel:"noopener noreferrer"};function c(u,e){const o=p("ExternalLinkIcon");return l(),i("div",null,[e[1]||(e[1]=a("h1",{id:"composite",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#composite"},[a("span",null,"Composite")])],-1)),e[2]||(e[2]=a("h2",{id:"gabriel-ferreira-lima-brito-20212tadssaj0015",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#gabriel-ferreira-lima-brito-20212tadssaj0015"},[a("span",null,"Gabriel Ferreira Lima Brito (20212TADSSAJ0015)")])],-1)),a("p",null,[a("a",d,[e[0]||(e[0]=t("@gabrielflb")),r(o)])]),e[3]||(e[3]=n('<h1 id="composite-seminario-2" tabindex="-1"><a class="header-anchor" href="#composite-seminario-2"><span>Composite - Seminario 2.</span></a></h1><hr><h2 id="intencao" tabindex="-1"><a class="header-anchor" href="#intencao"><span>INTENÇÃO</span></a></h2><ul><li>Compor objetos em estruturas de árvore para representar hierarquias parte-todo. O Composite permite que os clientes tratem objetos individuais e composições de objetos de maneira uniforme.</li></ul><hr><h2 id="tambem-conhecido-como" tabindex="-1"><a class="header-anchor" href="#tambem-conhecido-como"><span>Também Conhecido Como</span></a></h2><ul><li>Padrão de composição de objetos.</li></ul><hr><h2 id="motivacao" tabindex="-1"><a class="header-anchor" href="#motivacao"><span>Motivação</span></a></h2><ul><li><p>Os programas que lidam com gráficos para interfaces de usuário devem lidar com objetos complexos compostos por objetos menores. Por exemplo, um diagrama pode consistir de textos, linhas, círculos, retângulos, e outras figuras. Essas figuras podem ser agrupadas para formar figuras mais complexas. Essas, por sua vez, podem ser agrupadas para formar figuras ainda maiores.</p></li><li><p>O exemplo mais simples de agrupamento é uma linha composta, que pode ser composta de várias linhas simples. A interface do cliente não deve diferenciar entre uma linha composta e uma linha simples, mesmo que a linha composta seja composta por várias outras linhas. O cliente deve poder tratar um grupo de figuras da mesma forma que trata uma figura única.</p></li><li><p>Isso pode ser conseguido definindo classes que representam tanto figuras simples quanto compostas. A classe que representa figuras compostas deve armazenar um conjunto de referências para outras figuras, que podem ser simples ou compostas. A composição é recursiva, pois figuras compostas podem incluir outras figuras compostas.</p></li><li><p>Como resultado, as operações que tratam as figuras simples podem ser aplicadas às figuras compostas de maneira recursiva, sem que o cliente precise diferenciar entre figuras simples e compostas.</p></li></ul><img src="https://www.plantuml.com/plantuml/svg/ZP5D2i8m48NtSuhWoXzQS5kA50gkN7c3COarq2QIfDseTpTjqa1GhDdCyFZUP5vI6OlQzbqBrPSEy6AiHce9RT4OSXHDhv4yWBYpOznmUKEztXHaK8B12y1p9-7qPQmMclQjMWRFtA9i_aBzYhNgxih5c7baWWebdI54k4vbTa-CvfqQ-2_YuzPHpJne2fVQsDAx3-D2OL3vp3B_8eaImYTQp9ceQQHvReoe8a8Aijhd-NO5K779fX-CNQXl" alt="uml diagram" loading="lazy"><ul><li>A interface <strong>Figura</strong>, que tem como metodo abstrato <strong>desenhar()</strong>.</li><li>Os objetos <strong>Linha, Circulo e Retangulo</strong> implementam <strong>Figura</strong> e seu metodo.</li><li><strong>FiguraComposta</strong> possui uma lista de <strong>Figuras</strong>, podendo criar figuras complexas.</li><li>Dessa forma o cliente pode tratar figuras unicas e compostas de uma maneira uniforme.</li></ul><hr><h2 id="aplicabilidade" tabindex="-1"><a class="header-anchor" href="#aplicabilidade"><span>Aplicabilidade</span></a></h2><h3 id="use-o-padao-composite-quando" tabindex="-1"><a class="header-anchor" href="#use-o-padao-composite-quando"><span>Use o padão Composite quando:</span></a></h3><ul><li><p>Precisar representar objetos que são compostos de sub-objetos, que por sua vez podem ser compostos de outros sub-objetos.</p></li><li><p>Desejar que os clientes tratem objetos individuais e composições de objetos de maneira uniforme, sem precisar diferenciar entre os dois.</p></li><li><p>Precisar de uma estrutura de objetos que pode ser recursivamente aninhada, ou seja, um objeto pode conter outros objetos do mesmo tipo.</p></li><li><p>Esperar que novos tipos de componentes sejam adicionados ao sistema e deseja que isso seja feito de forma fácil e consistente.</p></li></ul><hr><h2 id="estrutura" tabindex="-1"><a class="header-anchor" href="#estrutura"><span>Estrutura</span></a></h2><h3 id="o-padrao-composite-normalmente-envolve-os-seguintes-componentes" tabindex="-1"><a class="header-anchor" href="#o-padrao-composite-normalmente-envolve-os-seguintes-componentes"><span>O padrão Composite normalmente envolve os seguintes componentes:</span></a></h3><ul><li><p><strong>Component</strong> : declara a interface para objetos na composição. Define uma interface para acessar e gerenciar componentes filhos opcionais.</p></li><li><p><strong>Leaf/folha</strong>: Representa objetos finais na composição, que não possuem filhos. Define o comportamento para objetos primitivos na composição.</p></li><li><p><strong>Composite/Nó</strong>: Define o comportamento para componentes que têm filhos. Armazena filhos e implementa operações relacionadas aos filhos.</p></li><li><p><strong>Client</strong>: Manipula objetos na composição através da interface &quot;Component&quot;;</p></li></ul><img src="https://www.plantuml.com/plantuml/svg/ZPBHQiCm34NV_HLwJDcI3mXb1FfQnc1Ve2PgCIHMiTLIsFhlSsmjP4rBboSXttkk9QS9WbvEGs-QgJAu2-An5MXx304sF1pPaPCFpzr96BuCnEy59js-PnGuK5HGoyNAN8t9tYtX_jT65o7NFUILy2dUkWCu7aWx6NmSgPev0nQZi5RNQrRLsR9IzU9YkQr1iVyU4LFxpBQ3eCqv_5QGQVS2bIoSY_agDcWl-7m9MnjaVNlw5gTBHT2S12kUZ9ckYvrjBJlq8wfGJBt8hwhgZytJm6Vwj-Vkt8iPrzzbEN_11ueqd35DN5Jw7xNu0G00" alt="uml diagram" loading="lazy"><hr><h2 id="participantes" tabindex="-1"><a class="header-anchor" href="#participantes"><span>Participantes</span></a></h2><ul><li><p><strong>ComponentProduto</strong> : Interface que sera implementada pelos componentes filhos que sera comum ao todo. Conhecida como nó/pai na estrutura de ávore.</p></li><li><p><strong>LeafProduto</strong> : &quot;Produto folha&quot; implementa <strong>ComponentProduto</strong> representa um produto comum, uma instância de um produto. Em estrutura de árvore é um filho.</p></li><li><p><strong>Caixa</strong> : &quot;Caixa&quot; pode ser entendido como tipo composite, que ira implementar <strong>ComponentProduto</strong> e possui uma lista do mesmo. Caixa também é um nó, podendo ter seus proprios filhos, tanto produtos finais/folhas como mais nós.</p></li></ul><h2 id="consequencias" tabindex="-1"><a class="header-anchor" href="#consequencias"><span>Consequencias</span></a></h2><h3 id="vantagens" tabindex="-1"><a class="header-anchor" href="#vantagens"><span>Vantagens:</span></a></h3><ul><li>implicidade no código do cliente: Permite que o cliente trate composições e objetos individuais de maneira uniforme.</li><li>Facilidade de adição de novos tipos de componentes: Novos tipos de Leafs e Composites podem ser facilmente adicionados.</li></ul><h3 id="desvantagens" tabindex="-1"><a class="header-anchor" href="#desvantagens"><span>Desvantagens:</span></a></h3><ul><li>Complexidade da implementação: Pode resultar em uma estrutura de classes complexa e difícil de entender, especialmente quando há muitos tipos de objetos.</li></ul><hr><h2 id="implementacao" tabindex="-1"><a class="header-anchor" href="#implementacao"><span>Implementação</span></a></h2><ul><li><p>Criar uma interface ou classe abstrata que declare os métodos que serão utilizados por todos os componentes da hierarquia.</p></li><li><p>Criar classes que representem objetos finais na hierarquia. Estes objetos não têm filhos e implementam a interface &quot;Component&quot;.</p></li><li><p>Criar classes que representem objetos que podem conter outros objetos &quot;Component&quot;. Estas classes também implementam a interface !Component&quot;.</p></li><li><p>Criar um cliente que manipule a hierarquia de objetos através da interface Component.</p></li></ul><hr><h2 id="usos-conhecidos" tabindex="-1"><a class="header-anchor" href="#usos-conhecidos"><span>Usos conhecidos</span></a></h2><ul><li>Interfaces Gráficas de Usuário (GUIs).</li><li>Sistemas de Arquivos.</li><li>Estruturas de Documentos.</li></ul><hr><h2 id="padroes-relacionados" tabindex="-1"><a class="header-anchor" href="#padroes-relacionados"><span>Padrões Relacionados</span></a></h2><ul><li><p>Decorator : Enquanto o padrão Composite trata a composição de objetos em uma hierarquia parte-todo, o Decorator foca na adição de funcionalidades a objetos individuais. Ambos podem ser usados juntos para criar uma estrutura onde objetos compostos (Composite) podem ser dinamicamente decorados com novas funcionalidades.</p></li><li><p>Builder : O padrão Builder pode ser usado para criar hierarquias complexas de objetos que seguem o padrão Composite. Ele pode ajudar a construir a estrutura hierárquica de um Composite de maneira mais controlada e flexível.</p></li><li><p>Strategy : A Strategy pode ser usada em conjunto com Composite para permitir que diferentes algoritmos sejam aplicados a diferentes partes da hierarquia. Por exemplo, diferentes estratégias de renderização podem ser usadas para diferentes tipos de objetos na estrutura Composite.</p></li></ul><hr><h2 id="referencias" tabindex="-1"><a class="header-anchor" href="#referencias"><span>Referências</span></a></h2><p>Composite em Java. Disponivel em : https://refactoring.guru/pt-br/design-patterns/composite/java/example#example-0. Acesso em Setembro 2024.</p><p>Composite Pattern. Disponivel em : https://springframework.guru/gang-of-four-design-patterns/composite-pattern/. Acesso em Setembro 2024.</p>',42))])}const f=s(m,[["render",c],["__file","Composite.html.vue"]]),b=JSON.parse('{"path":"/posts/Seminarios/seminario-2/Composite.html","title":"Composite","lang":"pt-BR","frontmatter":{"icon":"edit","date":"2024-08-22T23:10:00.000Z","tag":["Composite","gof"],"category":["seminario-2"],"order":10,"excerpt":"Apresentação do Padrão de Projeto Composite","author":"gabrielflb","gitInclude":["../../../../src/includes/seminario-2-gabrielflb/README.md"],"description":"Composite Gabriel Ferreira Lima Brito (20212TADSSAJ0015) @gabrielflb Composite - Seminario 2. INTENÇÃO Compor objetos em estruturas de árvore para representar hierarquias parte-...","head":[["meta",{"property":"og:url","content":"https://20241-ifba-saj-ads-ppr.github.io/blog-material-aula/blog-material-aula/posts/Seminarios/seminario-2/Composite.html"}],["meta",{"property":"og:site_name","content":"20241 PPR Blog das Aulas"}],["meta",{"property":"og:title","content":"Composite"}],["meta",{"property":"og:description","content":"Composite Gabriel Ferreira Lima Brito (20212TADSSAJ0015) @gabrielflb Composite - Seminario 2. INTENÇÃO Compor objetos em estruturas de árvore para representar hierarquias parte-..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"pt-BR"}],["meta",{"property":"og:updated_time","content":"2024-09-30T13:40:45.000Z"}],["meta",{"property":"article:author","content":"gabrielflb"}],["meta",{"property":"article:tag","content":"Composite"}],["meta",{"property":"article:tag","content":"gof"}],["meta",{"property":"article:published_time","content":"2024-08-22T23:10:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-30T13:40:45.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Composite\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-08-22T23:10:00.000Z\\",\\"dateModified\\":\\"2024-09-30T13:40:45.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gabrielflb\\"}]}"]]},"headers":[{"level":2,"title":"Gabriel Ferreira Lima Brito (20212TADSSAJ0015)","slug":"gabriel-ferreira-lima-brito-20212tadssaj0015","link":"#gabriel-ferreira-lima-brito-20212tadssaj0015","children":[]},{"level":2,"title":"INTENÇÃO","slug":"intencao","link":"#intencao","children":[]},{"level":2,"title":"Também Conhecido Como","slug":"tambem-conhecido-como","link":"#tambem-conhecido-como","children":[]},{"level":2,"title":"Motivação","slug":"motivacao","link":"#motivacao","children":[]},{"level":2,"title":"Aplicabilidade","slug":"aplicabilidade","link":"#aplicabilidade","children":[{"level":3,"title":"Use o padão Composite quando:","slug":"use-o-padao-composite-quando","link":"#use-o-padao-composite-quando","children":[]}]},{"level":2,"title":"Estrutura","slug":"estrutura","link":"#estrutura","children":[{"level":3,"title":"O padrão Composite normalmente envolve os seguintes componentes:","slug":"o-padrao-composite-normalmente-envolve-os-seguintes-componentes","link":"#o-padrao-composite-normalmente-envolve-os-seguintes-componentes","children":[]}]},{"level":2,"title":"Participantes","slug":"participantes","link":"#participantes","children":[]},{"level":2,"title":"Consequencias","slug":"consequencias","link":"#consequencias","children":[{"level":3,"title":"Vantagens:","slug":"vantagens","link":"#vantagens","children":[]},{"level":3,"title":"Desvantagens:","slug":"desvantagens","link":"#desvantagens","children":[]}]},{"level":2,"title":"Implementação","slug":"implementacao","link":"#implementacao","children":[]},{"level":2,"title":"Usos conhecidos","slug":"usos-conhecidos","link":"#usos-conhecidos","children":[]},{"level":2,"title":"Padrões Relacionados","slug":"padroes-relacionados","link":"#padroes-relacionados","children":[]},{"level":2,"title":"Referências","slug":"referencias","link":"#referencias","children":[]}],"git":{"createdTime":1727703645000,"updatedTime":1727703645000,"contributors":[{"name":"Leandro Costa","email":"leandro.costa@ifba.edu.br","commits":1}]},"readingTime":{"minutes":0.13,"words":40},"filePathRelative":"posts/Seminarios/seminario-2/Composite.md","localizedDate":"22 de agosto de 2024","autoDesc":true}');export{f as comp,b as data};
