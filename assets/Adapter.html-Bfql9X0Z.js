import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c,b as e,d as t,e as s,a as n,o as l,r as i}from"./app-BrOvOMMH.js";const d={},u={href:"https://github.com/Arlei10",target:"_blank",rel:"noopener noreferrer"},m={href:"https://github.com/SalvadorCerqueiraJr",target:"_blank",rel:"noopener noreferrer"};function b(v,a){const o=i("ExternalLinkIcon"),r=i("Mermaid");return l(),c("div",null,[a[2]||(a[2]=e("h1",{id:"adapter",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#adapter"},[e("span",null,"Adapter")])],-1)),a[3]||(a[3]=e("h2",{id:"arlei-nobrega-oliveira-20221tadssaj0012",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#arlei-nobrega-oliveira-20221tadssaj0012"},[e("span",null,"Árlei Nóbrega Oliveira (20221TADSSAJ0012)")])],-1)),e("p",null,[e("a",u,[a[0]||(a[0]=t("@Arlei10")),s(o)])]),a[4]||(a[4]=n(`<h1 id="adapter-1" tabindex="-1"><a class="header-anchor" href="#adapter-1"><span>Adapter</span></a></h1><h2 id="intencao" tabindex="-1"><a class="header-anchor" href="#intencao"><span>Intenção</span></a></h2><p>Converter a interface de uma classe em outra interface esparada pelos clientes. O Adapter permite que certas classes trabalhem em conjunto, pois de outra forma seria impossível por causa de suas interfaces imcompatíveis.</p><h2 id="sobre-o-adapter" tabindex="-1"><a class="header-anchor" href="#sobre-o-adapter"><span>Sobre o adapter</span></a></h2><ul><li>É um padrão da categoria estrutural</li><li>Faz exatamente o que um adaptador da vida real faz ( pense em um adaptador de tomadas de um formato para o outro ).</li><li>É muito usado para definir limites dentro de camadas da aplicação.</li><li>Tambem pode ser usado para adaptar interfaces de código legado para um novo código</li></ul><h2 id="problema" tabindex="-1"><a class="header-anchor" href="#problema"><span>Problema</span></a></h2><p>Imagine que você está criando uma aplicação de monitoramento do mercado de ações da bolsa. A aplicação baixa os dados as ações de múltiplas fontes em formato XML e então mostra gráficos e diagramas maneiros para o usuário.</p><p>Em algum ponto, você decide melhorar a aplicação ao integrar uma biblioteca de análise de terceiros. Mas aqui está a pegadinha: a biblioteca só trabalha com dados em formato JSON.<br><img src="https://github.com/user-attachments/assets/5198047c-b23c-45e6-9785-92bff3c0df11" alt="exemplo" loading="lazy"></p><p>A estrutura da aplicação antes da integração com a biblioteca de análises Você não pode usar a biblioteca “como ela está” porque ela espera os dados em um formato que é incompatível com sua aplicação.</p><p>Você poderia mudar a biblioteca para que ela funcione com XML. Contudo, isso pode quebrar algum código existente que depende da biblioteca. E pior, você pode não ter acesso ao código fonte da biblioteca para começo de conversa, fazendo dessa abordagem uma tarefa impossível.</p><h2 id="solucao" tabindex="-1"><a class="header-anchor" href="#solucao"><span>Solução</span></a></h2><p>Você pode criar um adaptador. Ele é um objeto especial que converte a interface de um objeto para que outro objeto possa entendê-lo.</p><p>Um adaptador encobre um dos objetos para esconder a complexidade da conversão acontecendo nos bastidores. O objeto encobrido nem fica ciente do adaptador. Por exemplo, você pode encobrir um objeto que opera em metros e quilômetros com um adaptador que converte todos os dados para unidades imperiais tais como pés e milhas.</p><p>Adaptadores podem não só converter dados em vários formatos, mas também podem ajudar objetos com diferentes interfaces a colaborar. Veja aqui como funciona:</p><ol><li>O adaptador obtém uma interface, compatível com um dos objetos existentes.</li><li>Usando essa interface, o objeto existente pode chamar os métodos do adaptador com segurança.</li><li>Ao receber a chamada, o adaptador passa o pedido para o segundo objeto, mas em um formato e ordem que o segundo objeto espera.<br> Algumas vezes é possível criar um adaptador de duas vias que pode converter as chamadas em ambas as direções. <img src="https://github.com/user-attachments/assets/d7e08d6b-0a92-4a4b-a40c-92cfd6352d56" alt="Capturar2" loading="lazy"><br> Vamos voltar à nossa aplicação da bolsa de valores. Para resolver o dilema dos formatos incompatíveis, você pode criar adaptadores XML-para-JSON para cada classe da biblioteca de análise que seu código trabalha diretamente. Então você ajusta seu código para comunicar-se com a biblioteca através desses adaptadores. Quando um adaptador recebe uma chamada, ele traduz os dados entrantes XML em uma estrutura JSON e passa a chamada para os métodos apropriados de um objeto de análise encoberto.</li></ol><h2 id="estrutura" tabindex="-1"><a class="header-anchor" href="#estrutura"><span>Estrutura</span></a></h2><h3 id="composicao" tabindex="-1"><a class="header-anchor" href="#composicao"><span>Composição</span></a></h3><figure><img src="https://github.com/user-attachments/assets/eff20590-ca2a-41d8-9494-32b779b17026" alt="Estrutura" tabindex="0" loading="lazy"><figcaption>Estrutura</figcaption></figure><h3 id="heranca-multipla" tabindex="-1"><a class="header-anchor" href="#heranca-multipla"><span>Herança Multipla</span></a></h3><figure><img src="https://github.com/user-attachments/assets/53c663da-e7b7-4d18-985c-e4e9f3361b9a" alt="estr" tabindex="0" loading="lazy"><figcaption>estr</figcaption></figure><ul><li>Essa implementação utiliza herança: o adaptador herda interfaces de ambos os objetos ao mesmo tempo. Observe que essa abordagem só pode ser implementada em linguagens de programação que suportam herança múltipla, tais como C++.</li></ul><hr><p>Client = é uma classe que contém a lógica de negócio do programa existente.<br> Target = Interface que descreve um protocolo que outras classes devem seguir para ser capaz de colaborar com o código cliente.<br> Adapter = É uma classe que é capaz de trabalhar tanto com o client quanto o adaptee: ela implementa a interface do cliente enquanto encobre o objeto do adaptee. O adaptador recebe chamadas do cliente através da interface do cliente e as traduz em chamadas para o objeto encobrido do adaptee em um formato que ele possa entender.<br> Adaptee = É alguma classe útil (geralmente de terceiros ou código legado). O cliente não pode usar essa classe diretamente porque ela tem uma interface incompatível.</p><h2 id="exemplo-de-implementacao" tabindex="-1"><a class="header-anchor" href="#exemplo-de-implementacao"><span>Exemplo de Implementação</span></a></h2><p>Segue abaixo um exemplo de implementação em Java utilizando o Padrão Adapter.<br> Este exemplo mostra como adaptar uma interface de reprodutor de áudio para tocar arquivos WAV</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ReprodutorDeAudio</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">tocar</span><span class="token punctuation">(</span><span class="token class-name">String</span> arquivo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReprodutorWAV</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">tocarWAV</span><span class="token punctuation">(</span><span class="token class-name">String</span> arquivo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Tocando arquivo WAV: &quot;</span> <span class="token operator">+</span> arquivo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReprodutorWAVAdapter</span> <span class="token keyword">implements</span> <span class="token class-name">ReprodutorDeAudio</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">ReprodutorWAV</span> reprodutorWAV<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">ReprodutorWAVAdapter</span><span class="token punctuation">(</span><span class="token class-name">ReprodutorWAV</span> reprodutorWAV<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>reprodutorWAV <span class="token operator">=</span> reprodutorWAV<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">tocar</span><span class="token punctuation">(</span><span class="token class-name">String</span> arquivo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        reprodutorWAV<span class="token punctuation">.</span><span class="token function">tocarWAV</span><span class="token punctuation">(</span>arquivo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Cliente</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ReprodutorDeAudio</span> reprodutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReprodutorWAVAdapter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ReprodutorWAV</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        reprodutor<span class="token punctuation">.</span><span class="token function">tocar</span><span class="token punctuation">(</span><span class="token string">&quot;musica.wav&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Neste exemplo, a interface <em>ReprodutorDeAudio</em> é a interface esperada pela aplicação. A classe <em>ReprodutorWAV</em> é a classe que precisa ser adaptada. O <em>ReprodutorWAVAdapter</em> é o adaptador que faz a adaptação entre as duas interfaces.</li></ul><h2 id="aplicabilidade" tabindex="-1"><a class="header-anchor" href="#aplicabilidade"><span>Aplicabilidade</span></a></h2><p>Use o padrão quando:</p><ul><li>Você não quiser que seu código dependa diretamente de código de terceiros ou legado.</li><li>Você quiser usar uma classe existente , mas sua interface for incopampatível com sua interface que seu código ou domínio precisam.</li><li>Você quiser reutilizar várias subclasses que não possuam determinada funcionalidade mas for impraticável estender o código de cada uma apenas para adicionar a funcionalidade desejada ( o Decorator também faz isso)</li></ul><h2 id="observacoes" tabindex="-1"><a class="header-anchor" href="#observacoes"><span>Observações</span></a></h2><p>O padrão Adapter é bastante comum no código Java. É frequentemente usado em sistemas baseados em algum código legado. Nesses casos, os adaptadores criam código legado com classes modernas.</p><p>Existem alguns adapters padrão nas bibliotecas principais do Java:</p><p>java.util.Arrays#asList()<br> java.util.Collections#list()<br> java.util.Collections#enumeration()<br> java.io.InputStreamReader(InputStream) (retorna um objeto Reader)<br> java.io.OutputStreamWriter(OutputStream) (retorna um objeto Writer)<br> javax.xml.bind.annotation.adapters.XmlAdapter#marshal() e #unmarshal ()</p><h2 id="exemplo-de-implementacao-2" tabindex="-1"><a class="header-anchor" href="#exemplo-de-implementacao-2"><span>Exemplo de Implementação 2</span></a></h2><p>Segue exemplo onde se tem um controle de Xbox e quer usá-lo para jogar em um PS4, utilizando um adaptador para mapear os controles.</p><ul><li>Interface do Controle do Xbox<br><strong>Esta interface define os métodos que um controle do Xbox deve implementar. Cada método corresponde a um botão no controle do Xbox.</strong></li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">XboxController</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">pressA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">pressB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">pressX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">pressY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Implementação do Controle do Xbox<br><strong>Esta classe implementa a interface XboxController e define o comportamento de cada botão do controle do Xbox.</strong></li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">XboxControllerImpl</span> <span class="token keyword">implements</span> <span class="token class-name">XboxController</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pressA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Botão A pressionado no controle do Xbox.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pressB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Botão B pressionado no controle do Xbox.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pressX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Botão X pressionado no controle do Xbox.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pressY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Botão Y pressionado no controle do Xbox.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Interface do Controle do PS4<br><strong>Esta interface define os métodos que um controle do PS4 deve implementar. Cada método corresponde a um botão no controle do PS4.</strong></li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">PS4Controller</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">pressSquare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">pressCircle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">pressTriangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">pressCross</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Implementação do Controle do PS4<br><strong>Esta classe implementa a interface PS4Controller e define o comportamento de cada botão do controle do PS4.</strong></li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PS4ControllerImpl</span> <span class="token keyword">implements</span> <span class="token class-name">PS4Controller</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pressSquare</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Botão Quadrado pressionado no controle do PS4.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pressCircle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Botão Círculo pressionado no controle do PS4.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pressTriangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Botão Triângulo pressionado no controle do PS4.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pressCross</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Botão Cruz pressionado no controle do PS4.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Adaptador<br><strong>O adaptador XboxToPS4Adapter implementa a interface PS4Controller, mas internamente usa um objeto XboxController. Cada método da interface PS4Controller é mapeado para o método correspondente do XboxController. Por exemplo, quando pressSquare() é chamado, ele chama pressX() no controle do Xbox.</strong></li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">XboxToPS4Adapter</span> <span class="token keyword">implements</span> <span class="token class-name">PS4Controller</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">XboxController</span> xboxController<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">XboxToPS4Adapter</span><span class="token punctuation">(</span><span class="token class-name">XboxController</span> xboxController<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>xboxController <span class="token operator">=</span> xboxController<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pressSquare</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        xboxController<span class="token punctuation">.</span><span class="token function">pressX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pressCircle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        xboxController<span class="token punctuation">.</span><span class="token function">pressB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pressTriangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        xboxController<span class="token punctuation">.</span><span class="token function">pressY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pressCross</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        xboxController<span class="token punctuation">.</span><span class="token function">pressA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Uso do adaptador no jogo<br><strong>Neste exemplo, criamos uma instância de XboxControllerImpl e a passamos para o adaptador XboxToPS4Adapter. Depois, usamos o adaptador como se fosse um controle do PS4. Quando chamamos os métodos do adaptador, ele redireciona as chamadas para os métodos correspondentes do controle do Xbox.</strong></li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Game</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">XboxController</span> xboxController <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XboxControllerImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">PS4Controller</span> ps4Adapter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XboxToPS4Adapter</span><span class="token punctuation">(</span>xboxController<span class="token punctuation">)</span><span class="token punctuation">;</span>

        ps4Adapter<span class="token punctuation">.</span><span class="token function">pressSquare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ps4Adapter<span class="token punctuation">.</span><span class="token function">pressCircle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ps4Adapter<span class="token punctuation">.</span><span class="token function">pressTriangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ps4Adapter<span class="token punctuation">.</span><span class="token function">pressCross</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li></li><li>O padrão Adapter permite que você use um controle do Xbox em um sistema que espera um controle do PS4, sem precisar modificar o código existente que usa o controle do PS4. O adaptador faz a tradução entre as interfaces, permitindo que os dois sistemas trabalhem juntos.</li></ul><h2 id="uml-da-implementacao" tabindex="-1"><a class="header-anchor" href="#uml-da-implementacao"><span>Uml da implementação</span></a></h2>`,50)),s(r,{id:"mermaid-229",code:"eJxLzkksLnbJTEwvSszlUgACsIBCRFJ+hXN+XklRfk5OapFCNVgKBLQLilKLix01NNFEnDBEIjBEIqEitVw4bfLMLcihpW0BwSZ4vBVcWJpYlIphknNmUXIOpnBIUWZiXjoWCeei/OJigrZj9SqtXQAK7ZB8oDscUxILSlCCQBctzitQuHRzJ5orbGp0dbGkEbBS1MgEq8QIYVwK0QMCbjdK6Ojq2qFZzgUAmkDnUg=="}),a[5]||(a[5]=n('<h2 id="consequencias" tabindex="-1"><a class="header-anchor" href="#consequencias"><span>Consequências</span></a></h2><h3 id="bom" tabindex="-1"><a class="header-anchor" href="#bom"><span>Bom</span></a></h3><ul><li>Desacopla o código da aplicação de codigos terceiros</li><li>Aplica o SRP ao separar a conversão de interfaces da lógica da aplicação</li><li>Aplica o OCP ao permitir introduzir novos Adapters para código existente</li></ul><h3 id="ruim" tabindex="-1"><a class="header-anchor" href="#ruim"><span>Ruim</span></a></h3><ul><li>A complexidade geral do código aumenta porque você precisa introduzir um conjunto de novas interfaces e classes. Algumas vezes é mais simples mudar a classe serviço para que ela se adeque com o resto do seu código.</li></ul><h2 id="relacoes-com-os-demais-padroes" tabindex="-1"><a class="header-anchor" href="#relacoes-com-os-demais-padroes"><span>Relações com os demais padrões</span></a></h2><ul><li><p>O Bridge é geralmente definido com antecedência, permitindo que você desenvolva partes de uma aplicação independentemente umas das outras. Por outro lado, o Adapter é comumente usado em aplicações existentes para fazer com que classes incompatíveis trabalhem bem juntas.</p></li><li><p>O Adapter fornece uma interface completamente diferente para acessar um objeto existente. Por outro lado, com o padrão Decorator, a interface permanece a mesma ou é estendida. Além disso, o Decorator oferece suporte à composição recursiva, o que não é possível quando você usa o Adapter.</p></li><li><p>Com Adapter, você acessa um objeto existente por meio de uma interface diferente. Com Proxy, a interface permanece a mesma. Com Decorator, você acessa o objeto por meio de uma interface aprimorada.</p></li><li><p>O Facade define uma nova interface para objetos existentes, enquanto que o Adapter tenta fazer uma interface existente ser utilizável. O Adapter geralmente envolve apenas um objeto, enquanto que o Facade trabalha com um inteiro subsistema de objetos.</p></li><li><p>O Bridge, State, Strategy (e de certa forma o Adapter) têm estruturas muito parecidas. De fato, todos esses padrões estão baseados em composição, o que é delegar o trabalho para outros objetos. Contudo, eles todos resolvem problemas diferentes. Um padrão não é apenas uma receita para estruturar seu código de uma maneira específica. Ele também pode comunicar a outros desenvolvedores o problema que o padrão resolve.</p></li></ul><h2 id="salvador-cerqueira-junior-20212tadssaj0020" tabindex="-1"><a class="header-anchor" href="#salvador-cerqueira-junior-20212tadssaj0020"><span>Salvador Cerqueira Júnior (20212TADSSAJ0020)</span></a></h2>',8)),e("p",null,[e("a",m,[a[1]||(a[1]=t("@SalvadorCerqueiraJr")),s(o)])]),a[6]||(a[6]=n('<h1 id="adapter-2" tabindex="-1"><a class="header-anchor" href="#adapter-2"><span>Adapter</span></a></h1><p>O Adapter é um padrão de projeto estrutural que permite objetos com interfaces incompatíveis colaborarem entre si.</p><h2 id="intencao-1" tabindex="-1"><a class="header-anchor" href="#intencao-1"><span>Intenção</span></a></h2><p>Converter a interface de uma classe em outra interface, esperada pelos clientes. O Adapter permite que classes com interfaces incompatíveis trabalhem em conjunto – o que, de outra forma, seria impossível.</p><h2 id="tambem-conhecido-como" tabindex="-1"><a class="header-anchor" href="#tambem-conhecido-como"><span>Também conhecido como</span></a></h2><p>Wrapper</p><h2 id="motivacao" tabindex="-1"><a class="header-anchor" href="#motivacao"><span>Motivação</span></a></h2><p>Algumas vezes, uma classe de um toolkit, projetada para ser reutilizada não é reutilizável porque sua interface não corresponde à interface específica de um domínio requerida por uma aplicação.</p><p>Considere, por exemplo, um editor de desenhos que permite aos usuários desenhar e arranjar elementos gráficos (linhas, polígonos, texto, etc.) em figuras e diagramas. A abstração-chave do editor de desenhos é o objeto gráfico, o qual tem uma forma editável e pode desenhar a si próprio. A interface para objetos gráficos é definida por uma classe abstrata chamada Shape. O editor define uma subclasse de Shape para cada tipo de objeto gráfico: uma classe LineShape para linhas, uma classe PolygonShape para polígonos, e assim por diante.</p><p>Classes para formas geométricas elementares, como LineShape e PolygonShape, são bastante fáceis de ser implementadas porque as suas capacidades de desenho e edição são inerentemente limitadas. Mas uma subclasse TextShape que pode exibir e editar textos é mais difícil de ser implementada, uma vez que mesmo a edição básica de textos envolve atualizações complicadas de tela e gerência de buffer. Entretanto, pode já existir um toolkit para construção de interfaces de usuários, o qual já oferece uma sofisticada classe TextView para a exibição e edição de textos. Idealmente, gostaríamos de reutilizar TextView para implementar TextShape, porém, o toolkit não foi projetado levando classes Shape em consideração. Assim, não podemos usar de maneira intercambiável objetos TextView e Shape.</p><p>Como é possível que classes existentes e não-relacionadas, como TextView, funcionem em uma aplicação que espera classes com uma interface diferente e incompatível? Poderíamos mudar a classe TextView de maneira que ela fosse coerente com a interface de Shape, porém, a menos que tenhamos o código-fonte do toolkit, essa opção não é viável. Mesmo que tivéssemos o código-fonte, não teria sentido mudar TextView; o toolkit não deveria ter que adotar interfaces específicas de domínios somente para fazer com que uma aplicação funcione.</p><p>Em vez disso, poderíamos definir TextShape de maneira que ele adapte a interface de TextView àquela de Shape. Podemos fazer isto de duas maneiras: (1) herdando a interface de Shape e a implementação de TextView, ou (2) compondo uma instância de TextView dentro de uma TextShape e implementando TextShape em termos da interface de TextView.</p><p>Essas duas abordagens correspondem às versões do padrão Adapter para classes e para objetos. Chamamos TextShape um adaptador.</p><figure><img src="https://github.com/user-attachments/assets/cb39c6fa-5ebb-4f6f-91af-891bd4a05f54" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>Este diagrama ilustra o caso de um adaptador para objetos. Ele mostra como solicitações de BoundingBox, declarada na classe Shape, são convertidas em solicitações para GetExtent, definida em TextView. Uma vez que TextShape adapta Text View à interface de Shape, o editor de desenhos pode reutilizar a classe TextView que seria incompatível de outra forma.</p><p>Freqüentemente, um adaptador é responsável por funcionalidades não oferecidas pela classe adaptada. O diagrama mostra como um adaptador pode atender tais responsabilidades. O usuário deveria ser capaz de “arrastar” cada objeto Shape para uma nova posição de forma interativa, porém, TextView não está projetada para fazer isso. TextShape pode acrescentar essa função através da implementação da operação CreateManipulator, de Shape, a qual retorna uma instância da subclasse Manipulator apropriada.</p><p>Manipulator é uma classe abstrata para objetos que sabem como animar um Shape em resposta à entrada de usuário, tal como arrastar a forma geométrica para uma nova localização. Existem subclasses de Manipulator para diferentes formas; por exemplo, TextManipulator é a subclasse correspondente para TextShape. Pelo retorno de uma instância de TextManipulator, TextShape acrescenta a funcionalidade que Shape necessita mas que TextView não tem.</p><h2 id="aplicabilidade-1" tabindex="-1"><a class="header-anchor" href="#aplicabilidade-1"><span>Aplicabilidade</span></a></h2><p>Use o padrão Adapter quando:</p><ul><li>você quiser usar uma classe existente, mas sua interface não corresponder à interface de que necessita;</li><li>você quiser criar uma classe reutilizável que coopere com classes não-relacionadas ou não-previstas, ou seja, classes que não necessariamente tenham interfaces compatíveis:</li><li>(somente para adaptadores de objetos) você precisar usar várias subclasses existentes, porém, for impraticável adaptar essas interfaces criando subclasses para cada uma. Um adaptador de objeto pode adaptar a interface da sua classe-mãe.</li></ul><h2 id="estrutura-1" tabindex="-1"><a class="header-anchor" href="#estrutura-1"><span>Estrutura</span></a></h2><ul><li><p>Um adaptador de classe usa a herança múltipla para adaptar uma interface à outra: <img src="https://github.com/user-attachments/assets/2e8051f5-8b9d-4687-b54f-85e2b924e65b" alt="image" loading="lazy"></p></li><li><p>Um adaptador de objeto depende da composição de objetos: <img src="https://github.com/user-attachments/assets/2943d0e9-5bd0-420f-9547-a7815c0d2836" alt="image" loading="lazy"></p></li></ul><h2 id="participantes" tabindex="-1"><a class="header-anchor" href="#participantes"><span>Participantes</span></a></h2><ul><li>Target (Shape): define a interface específica do domínio que Client usa.</li><li>Client (DrawingEditor): colabora com objetos compatíveis com a interface de Target.</li><li>Adaptee (TextView): define uma interface existente que necessita ser adaptada.</li><li>Adapter (TextShape): adapta a interface do Adaptee à interface de Target.</li></ul><h2 id="colaboracoes" tabindex="-1"><a class="header-anchor" href="#colaboracoes"><span>Colaborações</span></a></h2><p>• Os clientes chamam operações em uma instância de Adapter. Por sua vez, o adapter chama operações de Adaptee que executam a solicitação.</p><h2 id="consequencias-1" tabindex="-1"><a class="header-anchor" href="#consequencias-1"><span>Conseqüências</span></a></h2><p>Os adaptadores de classes e de objetos têm diferentes soluções de compromisso. Um adaptador de classe:</p><ul><li>adapta Adaptee a Target através do uso efetivo de uma classe Adapter concreta. Em conseqüência, um adaptador de classe não funcionará quando quisermos adaptar uma classe e todas as suas subclasses;</li><li>permite a Adapter substituir algum comportamento do Adaptee, uma vez que Adapter é uma subclasse de Adaptee;</li><li>introduz somente um objeto, e não é necessário endereçamento indireto adicional por ponteiros para chegar até o Adaptee.</li></ul><p>Um adaptador de objeto:</p><ul><li>permite a um único Adapter trabalhar com muitos Adaptees – isto é, o Adaptee em si e todas as suas subclasses (se existirem). O Adapter também pode acrescentar funcionalidade a todos os Adaptees de uma só vez;</li><li>torna mais difícil redefinir um comportamento de Adaptee. Ele exigirá a criação de subclasses de Adaptee e fará com que Adapter referencie a subclasse ao invés do Adaptee em si.</li></ul><p>Aqui apresentamos outros pontos a serem considerados quando usamos o padrão Adapter:</p><ol><li><p>Quanta adaptação Adapter faz? Os Adapters variam no volume de trabalho que executam para adaptar o Adaptee à interface de Target. Existe uma variação do trabalho possível, desde a simples conversão de interface – por exemplo, mudar os nomes das operações – até suportar um conjunto de operações inteiramente diferente. O volume de trabalho que o Adapter executa depende de quão similar é a interface de Target a dos seus Adaptees.</p></li><li><p>Adaptadores conectáveis (pluggable). Uma classe é mais reutilizável quando você minimiza as suposições que outras classes devem fazer para utilizá-la. Através da construção da adaptação de interface em uma classe, você elimina a suposição de que outras classes vêm a mesma interface. Dito de outra maneira, a adaptação de interfaces permite incorporar a nossa classe a sistemas existentes que podem estar esperando interfaces diferentes para a classe. ObjectWorks/ Smalltalk [Par90] usa o termo pluggable adapter para descrever classes com adaptação de interfaces incorporadas. Considere um widget TreeDisplay que pode exibir graficamente estruturas de árvore. Se este fosse um widget com uma finalidade especial para uso em apenas uma aplicação, então, poderíamos requerer uma interface específica dos objetos que ele exibisse; ou seja, todos deveriam descender de uma classe abstrata Tree. Mas se quiséssemos tornar TreeDisplay mais reutilizável (digamos que quiséssemos torná-la parte de um toolkit de widgets úteis), então essa exigência não seria razoável. Aplicações definirão suas próprias classes para estruturas de árvore. Elas não deveriam ser forçadas a usar a nossa classe abstrata Tree. Diferentes estruturas de árvores terão diferentes interfaces. Por exemplo, numa hierarquia de diretório, os descendentes podem ser acessados com uma operação GetSubdirectories, enquanto que numa hierarquia de herança, a operação correspondente poderia ser chamada GetSubclasses. Um widget TreeDisplay reutilizável deve ser capaz de exibir ambos os tipos de hierarquias ainda que usem interfaces diferentes. Em outras palavras, TreeDisplay deveria ter uma adaptação de interface incorporada a ele. Examinaremos diferentes maneiras de construir adaptações de interfaces, dentro de classes, na seção Implementação.</p></li><li><p>Utilização de adaptadores de dois sentidos para fornecer transparência. Um problema potencial com adaptadores decorre do fato de que eles não são transparentes para todos os clientes. Um objeto adaptado não oferece a interface do objeto original, por isso ele não pode ser usado onde o original o for. Adaptadores de dois sentidos (two-way adapters) podem fornecer essa transparência. Eles são úteis quando dois clientes diferentes necessitam ver um objeto de forma diferente. Considere o adaptador de dois sentidos que integra o Unidraw, um framework para editores gráficos [VL90], e QOCA, um toolkit para solução de restrições [HHMV92]. Ambos os sistemas possuem classes que representam variáveis explicitamente: Unidraw tem StateVariable e QOCA tem Constraint Variable. Para fazer com que Unidraw trabalhe com QOCA, Constraint Variable deve ser adaptada a StateVariable; para permitir que QOCA propague soluções para Unidraw, StateVariable deve ser adaptada a ConstraintVariable.</p></li></ol><figure><img src="https://github.com/user-attachments/assets/fcba4481-44b9-4d12-ba7a-51815367538e" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>A solução envolve o uso de um adaptador de classe ConstraintStateVariable de dois sentidos, uma subclasse tanto de StateVariable como de ConstraintVariable que adapta as duas interfaces uma à outra. Neste caso, a herança múltipla é uma solução viável porque as interfaces das classes adaptadas são substancialmente diferentes. O adaptador de classe de dois sentidos é compatível com ambas as classes adaptadas, podendo funcionar em ambos os sistemas.</p><h2 id="implementacao" tabindex="-1"><a class="header-anchor" href="#implementacao"><span>Implementação</span></a></h2><p>Embora a implementação do padrão Adapter seja normalmente simples e direta, apresentamos aqui alguns tópicos a serem sempre considerados:</p><ol><li>Implementando adaptadores de classe em C++. Numa implementação em C++ uma classe Adapter deveria herdar publicamente de Target e privadamente de Adaptee. Assim, Adapter seria um subtipo de Target, mas não de Adaptee.</li><li>Adaptadores conectáveis. Vamos examinar três maneiras de implementar adaptadores “plugáveis” para o widget TreeDisplay descrito anteriormente, os quais podem formatar e exibir uma estrutura hierárquica automaticamente. O primeiro passo, comum a todas as três implementações discutidas aqui, é encontrar uma interface “mínima” para Adaptee, ou seja, o menor subconjunto de operações que permite fazer a adaptação. Uma interface mínima, consistindo em somente um par de operações, é mais fácil de adaptar que uma interface com dúzias de operações. Para o TreeDisplay, o adaptee é qualquer estrutura hierárquica. Uma interface minimalista pode incluir duas operações, uma que define como apresentar graficamente um nó na estrutura hierárquica e outra que recupera os filhos do nó. A interface mínima conduz a três abordagens de implementação:</li></ol><p>(a) Utilizando operações abstratas. Defina na classe TreeDisplay operações abstratas correspondentes à interface mínima de Adaptee. As operações abstratas devem ser implementadas por subclasses que também adaptam o objeto hierarquicamente estruturado. Por exemplo, uma subclasse DirectoryTreeDisplay implementará essas operações acessando a estrutura do diretório.</p><figure><img src="https://github.com/user-attachments/assets/948d94dd-ec86-4e6e-a33c-40165d114503" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>DirectoryTreeDisplay especializa a interface mínima de maneira que possa exibir estruturas de diretório compostas de objetos FileSystemEntity.</p><p>(b) Utilizando objetos delegados. Nesta abordagem, o TreeDisplay repassa solicitações de acesso à estrutura hierárquica para um objeto delegado. O TreeDisplay pode usar uma estratégia de adaptação diferente pela substituição de um delegado por outro. Por exemplo, suponha que exista um DirectoryBrowser que usa um TreeDisplay. Directory Browser pode vir a ser um bom delegado para adaptar TreeDisplay à estrutura do diretório hierárquico. Em linguagens com tipos definidos dinamicamente, como Smalltalk ou Objective C, essa abordagem somente exige uma interface para registrar o delegado junto ao adapter. Então, o TreeDisplay simplesmente repassa as solicitações para o delegado. NEXTSTEP [Add94] usa essa abordagem intensamente para reduzir o uso de subclasses. As linguagens com tipos estaticamente definidos, como C++, requerem uma definição explícita da interface para o delegado. Podemos especificar tal interface colocando a interface mínima requerida por TreeDisplay em uma classe abstrata TreeAccessorDelegate. Então, podemos misturar essa interface com o delegado de nossa escolha – DirectoryBrowser, neste caso – usando herança. Usamos herança simples se o DirectoryBrowse não tiver classe-mãe, caso contrário, usamos herança múltipla. Misturar classes dessa maneira é mais fácil do que introduzir uma nova subclasse TreeDisplay e implementar suas operações individualmente.</p><figure><img src="https://github.com/user-attachments/assets/a58d043b-4180-4995-b902-583717ef9025" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>(c) Adapters parametrizados.</p><p>A maneira usual de suportar adaptadores conectáveis em Smalltalk é parametrizar um adaptador com um ou mais blocos (Smalltalk). A primitiva “block” suporta a adaptação sem usar subclasses. Um bloco pode adaptar uma solicitação e o adaptador pode armazenar um bloco para cada solicitação individual. No nosso exemplo, isso significa que TreeDisplay armazena um bloco para converter um nó em um GraphicNode e outro bloco para acessar os filhos de um nó. Por exemplo, para criar um TreeDisplay em uma hierarquia de diretório, escrevemos</p><figure><img src="https://github.com/user-attachments/assets/0d69bf55-bbe3-473b-a8d9-84f8cd7572b6" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>Se você está construindo uma adaptação de interface em uma classe, essa abordagem oferece uma alternativa conveniente ao uso de subclasses.</p><h2 id="exemplo-de-codigo" tabindex="-1"><a class="header-anchor" href="#exemplo-de-codigo"><span>Exemplo de código</span></a></h2><p>Apresentaremos um breve esboço da implementação de adaptadores de classes e de objetos para o exemplo apresentado na seção Motivação, começando com as classes Shape e TextView.</p><figure><img src="https://github.com/user-attachments/assets/c09e9d4e-8550-40a6-a669-0aca05ca82c2" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>Shape supõe uma caixa delimitadora definida pelos seus cantos opostos. Em contraste, TextView é definido por origem, altura e largura. Shape também define uma operação CreateManipulator para criar um objeto Manipulator, o qual sabe como animar uma forma quando um usuário a manipula.1 O TextView não tem uma operação equivalente. A classe TextShape é um adaptador entre essas diferentes interfaces.</p><p>Um adaptador de classe utiliza a herança múltipla para adaptar interfaces. O ponto-chave dos adaptadores de classe é a utilização de um ramo de herança para herdar a interface e de outro ramo para herdar a implementação. A maneira usual de fazer essa distinção em C++ é herdar a interface publicamente e herdar a implementação privadamente. Usaremos essa convenção para definir o adaptador TextShape.</p><p>A operação BoundingBox converte a interface de TextView para que esta fique de acordo com a interface de Shape.</p><figure><img src="https://github.com/user-attachments/assets/8a2f00bd-9fcb-40b6-adc9-add084a6e771" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>A operação IsEmpty demonstra o repasse direto de solicitações, comum em implementações de adaptadores:</p><figure><img src="https://github.com/user-attachments/assets/5b66ca13-4f3e-4b88-81ef-e0d06bee2478" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>Finalmente, definimos CreateManipulator (a qual não é suportada por TextView) a partir do zero. Assumimos que já implementamos uma classe TextManipulator que suporta manipulação de um TextShape.</p><figure><img src="https://github.com/user-attachments/assets/2da46f83-f4d7-4c47-b3d0-ee75468e331b" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>O adaptador de objeto utiliza composição de objetos para combinar classes que têm interfaces diferentes. Nesta abordagem, o adaptador TextShape mantém um apontador para TextView.</p><figure><img src="https://github.com/user-attachments/assets/f711c5a9-ee23-4a67-809f-dba2648057c9" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>TextShape deve iniciar o apontador para instância de TextView, e ele faz isso no constructor. Ele também deve invocar operações no seu objeto TextView sempre que suas próprias operações forem invocadas. Neste exemplo, presuma que o cliente crie o objeto TextView e o passe para o constructor de TextShape:</p><figure><img src="https://github.com/user-attachments/assets/15744c1f-ef1b-4a59-bdba-cab9b6584d3f" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>A implementação de CreateManipulator não muda em relação à versão para o adaptador de classe, uma vez que é implementada do zero e não reutiliza qualquer funcionalidade existente de TextView.</p><figure><img src="https://github.com/user-attachments/assets/5dc6f9d8-3f8d-403d-8d74-ca72c0c9f2a9" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>Compare este código com o código do caso do adaptador de classe. O adaptador de objeto exige um pouco mais de esforço para escrever, porém, é mais flexível. Por exemplo, a versão do adaptador de objeto de TextShape funcionará igualmente bem com subclasses de TextView – o cliente simplesmente passa uma instância de uma subclasse de TextView para o constructor de TextShape.</p><h2 id="usos-conhecidos" tabindex="-1"><a class="header-anchor" href="#usos-conhecidos"><span>Usos conhecidos</span></a></h2><p>O exemplo da seção Motivação vem do ET++Draw, uma aplicação de desenho baseada na ET++ [WGM88]. O ET++Draw reutiliza as classes para edição de texto da ET++ usando um adapter de classe TextShape. O InterViews 2.6 define uma classe abstrata Interactor para elementos da interface do usuário, tais como barras de rolamento, botões e menus [VL88]. Ele também define uma classe abstrata Graphic para objetos gráficos estruturados, tais como linhas, círculos, polígonos e “splines”. Tanto Interactors como Graphics têm aparências gráficas, porém, diferentes interfaces e implementações (eles não têm uma classe ancestral compartilhada) e são, portanto, incompatíveis – você não pode incluir diretamente um objeto gráfico estruturado em, por exemplo, uma caixa de diálogo.</p><p>Em vez disso, o InterViews 2.6 define um adaptador de objeto chamado GraphicBlock, uma subclasse de Interactor que contém uma instância de Graphic. O GraphicBlock adapta a interface da classe Graphic àquela de Interactor. O GraphicBlock permite que uma instância de Graphic seja exibida, rolada e possa sofrer zooms dentro de uma estrutura Interactor. Os adaptadores conectáveis são comuns em ObjectWorks\\Smalltalk. O Smalltalk-padrão define uma classe ValueModel para visões (views) que exibem um único valor. ValueModel define uma interface value, value: para acessar o valor. Estes são métodos abstratos. Programadores de aplicação acessam o valor usando nomes mais específicos do domínio, tais como width e width:, mas eles não deveriam ter que criar subclasses de ValueModel para adaptar tais nomes específicos da aplicação à interface de ValueModel.</p><p>Em vez disso, ObjectWorks\\Smalltalk inclui uma subclasse de ValueModel chamada PluggableAdaptor. Um objeto PluggableAdaptor adapta outros objetos à interface de ValueModel (value, value:). Ela pode ser parametrizada com blocos para obter e atualizar (set) o valor desejado. PluggableAdaptor utiliza internamente estes blocos para implementar a interface value, value:. PluggableAdaptor também permite passar nomes no Selector (por exemplo, width, width:) diretamente por conveniência sintática. Ela converte estes seletores (selectors) nos blocos correspondentes, de forma automática.</p><figure><img src="https://github.com/user-attachments/assets/b1dea922-efc0-4b40-9709-927e42e1fc75" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>Outro exemplo proveniente de ObjectWorks\\Smalltalk é a classe TableAdaptor. Uma TableAdaptor pode adaptar uma seqüência de objetos numa apresentação tabular. A tabela exibe um objeto por linha. O cliente parametriza TableAdaptor com um conjunto de mensagens que uma tabela pode usar para obter os valores de coluna de um objeto.</p><p>Algumas classes no AppKit do NeXT [Add94] usam objetos delegados para executar adaptação de interfaces. Um exemplo é a classe NXBrowser que pode exibir listas hierárquicas de dados. NXBrowser usa um objeto delegado para acessar e adaptar dados. O “Casamento de Conveniência” (“Marriage of Convenience”), [Mey88] de Meyer é uma forma de um adaptador de classe. Meyer descreve como uma classe FixedStack adapta a implementação de uma classe Array à interface de uma classe stack. O resultado é uma pilha (Stack) que contém um número fixo de entradas.</p><h2 id="padroes-relacionados" tabindex="-1"><a class="header-anchor" href="#padroes-relacionados"><span>Padrões relacionados</span></a></h2><p>O padrão Bridge(151) tem uma estrutura similar a um adaptador de objeto, porém, Bridge tem uma intenção diferente: tem por objetivo separar uma interface da sua implementação, de modo que elas possam variar fácil e independentemente. Um adaptador se destina a mudar a interface de um objeto existente.</p><p>O padrão Decorator (170) aumenta outro objeto sem mudar sua interface. Desta forma, um Decorator é mais transparente para a aplicação do que um adaptador.</p><p>Como conseqüência, Decorator suporta a composição recursiva, a qual não é possível com adaptadores puros.</p><p>O Proxy (198) define um representante ou “procurador”para outro objeto e nãomuda a sua interface.</p><h2 id="meu-exemplo" tabindex="-1"><a class="header-anchor" href="#meu-exemplo"><span>Meu exemplo</span></a></h2><h3 id="cenario" tabindex="-1"><a class="header-anchor" href="#cenario"><span>Cenário</span></a></h3><p>Você tem um sistema de carga de veículos elétricos que precisa lidar com diferentes tipos de conectores de carga, como o Tipo 1 e o Tipo 2. O sistema deve oferecer uma interface uniforme para carregar o veículo, independentemente do tipo de conector.</p><figure><img src="https://github.com/user-attachments/assets/e469e10f-3f20-4e60-aa56-2eb06fbac15e" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><h3 id="descricao-dos-componentes" tabindex="-1"><a class="header-anchor" href="#descricao-dos-componentes"><span>Descrição dos Componentes:</span></a></h3><ol><li>SistemaDeCarga: Classe que precisa carregar o veículo elétrico e interage com a interface Conector.</li><li>Conector: Interface que define o método conectar(), que o SistemaDeCarga espera.</li><li>AdaptadorTipo1: Classe que adapta o conector Tipo 1 para a interface Conector. Implementa o método conectar() usando uma instância de ConectorTipo1.</li><li>AdaptadorTipo2: Classe que adapta o conector Tipo 2 para a interface Conector. Implementa o método conectar() usando uma instância de ConectorTipo2.</li><li>ConectorTipo1: Classe que representa um conector de tipo 1 com o método conectarTipo1().</li><li>ConectorTipo2: Classe que representa um conector de tipo 2 com o método conectarTipo2().</li></ol><h2 id="referencia" tabindex="-1"><a class="header-anchor" href="#referencia"><span>Referência</span></a></h2><ol><li>AMMA, Erich. et al. Padrões de projetos: Soluções reutilizáveis de software orientados a objetos Bookman editora, 2009.</li></ol>',85))])}const g=p(d,[["render",b],["__file","Adapter.html.vue"]]),h=JSON.parse('{"path":"/posts/Seminarios/seminario-2/Adapter.html","title":"Adapter","lang":"pt-BR","frontmatter":{"icon":"edit","date":"2024-08-22T23:10:00.000Z","tag":["Adapter","gof"],"category":["seminario-2"],"order":10,"excerpt":"Apresentação do Padrão de Projeto Adapter","author":"Arlei10 SalvadorCerqueiraJr","gitInclude":["../../../../src/includes/seminario-2-Arlei10/README.md","../../../../src/includes/seminario-2-SalvadorCerqueiraJr/README.md"],"description":"Adapter Árlei Nóbrega Oliveira (20221TADSSAJ0012) @Arlei10 Adapter Intenção Converter a interface de uma classe em outra interface esparada pelos clientes. O Adapter permite que...","head":[["meta",{"property":"og:url","content":"https://20241-ifba-saj-ads-ppr.github.io/blog-material-aula/blog-material-aula/posts/Seminarios/seminario-2/Adapter.html"}],["meta",{"property":"og:site_name","content":"20241 PPR Blog das Aulas"}],["meta",{"property":"og:title","content":"Adapter"}],["meta",{"property":"og:description","content":"Adapter Árlei Nóbrega Oliveira (20221TADSSAJ0012) @Arlei10 Adapter Intenção Converter a interface de uma classe em outra interface esparada pelos clientes. O Adapter permite que..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"pt-BR"}],["meta",{"property":"og:updated_time","content":"2024-09-30T13:40:45.000Z"}],["meta",{"property":"article:author","content":"Arlei10 SalvadorCerqueiraJr"}],["meta",{"property":"article:tag","content":"Adapter"}],["meta",{"property":"article:tag","content":"gof"}],["meta",{"property":"article:published_time","content":"2024-08-22T23:10:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-30T13:40:45.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Adapter\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-08-22T23:10:00.000Z\\",\\"dateModified\\":\\"2024-09-30T13:40:45.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Arlei10 SalvadorCerqueiraJr\\"}]}"]]},"headers":[{"level":2,"title":"Árlei Nóbrega Oliveira (20221TADSSAJ0012)","slug":"arlei-nobrega-oliveira-20221tadssaj0012","link":"#arlei-nobrega-oliveira-20221tadssaj0012","children":[]},{"level":2,"title":"Intenção","slug":"intencao","link":"#intencao","children":[]},{"level":2,"title":"Sobre o adapter","slug":"sobre-o-adapter","link":"#sobre-o-adapter","children":[]},{"level":2,"title":"Problema","slug":"problema","link":"#problema","children":[]},{"level":2,"title":"Solução","slug":"solucao","link":"#solucao","children":[]},{"level":2,"title":"Estrutura","slug":"estrutura","link":"#estrutura","children":[{"level":3,"title":"Composição","slug":"composicao","link":"#composicao","children":[]},{"level":3,"title":"Herança Multipla","slug":"heranca-multipla","link":"#heranca-multipla","children":[]}]},{"level":2,"title":"Exemplo de Implementação","slug":"exemplo-de-implementacao","link":"#exemplo-de-implementacao","children":[]},{"level":2,"title":"Aplicabilidade","slug":"aplicabilidade","link":"#aplicabilidade","children":[]},{"level":2,"title":"Observações","slug":"observacoes","link":"#observacoes","children":[]},{"level":2,"title":"Exemplo de Implementação 2","slug":"exemplo-de-implementacao-2","link":"#exemplo-de-implementacao-2","children":[]},{"level":2,"title":"Uml da implementação","slug":"uml-da-implementacao","link":"#uml-da-implementacao","children":[]},{"level":2,"title":"Consequências","slug":"consequencias","link":"#consequencias","children":[{"level":3,"title":"Bom","slug":"bom","link":"#bom","children":[]},{"level":3,"title":"Ruim","slug":"ruim","link":"#ruim","children":[]}]},{"level":2,"title":"Relações com os demais padrões","slug":"relacoes-com-os-demais-padroes","link":"#relacoes-com-os-demais-padroes","children":[]},{"level":2,"title":"Salvador Cerqueira Júnior (20212TADSSAJ0020)","slug":"salvador-cerqueira-junior-20212tadssaj0020","link":"#salvador-cerqueira-junior-20212tadssaj0020","children":[]},{"level":2,"title":"Intenção","slug":"intencao-1","link":"#intencao-1","children":[]},{"level":2,"title":"Também conhecido como","slug":"tambem-conhecido-como","link":"#tambem-conhecido-como","children":[]},{"level":2,"title":"Motivação","slug":"motivacao","link":"#motivacao","children":[]},{"level":2,"title":"Aplicabilidade","slug":"aplicabilidade-1","link":"#aplicabilidade-1","children":[]},{"level":2,"title":"Estrutura","slug":"estrutura-1","link":"#estrutura-1","children":[]},{"level":2,"title":"Participantes","slug":"participantes","link":"#participantes","children":[]},{"level":2,"title":"Colaborações","slug":"colaboracoes","link":"#colaboracoes","children":[]},{"level":2,"title":"Conseqüências","slug":"consequencias-1","link":"#consequencias-1","children":[]},{"level":2,"title":"Implementação","slug":"implementacao","link":"#implementacao","children":[]},{"level":2,"title":"Exemplo de código","slug":"exemplo-de-codigo","link":"#exemplo-de-codigo","children":[]},{"level":2,"title":"Usos conhecidos","slug":"usos-conhecidos","link":"#usos-conhecidos","children":[]},{"level":2,"title":"Padrões relacionados","slug":"padroes-relacionados","link":"#padroes-relacionados","children":[]},{"level":2,"title":"Meu exemplo","slug":"meu-exemplo","link":"#meu-exemplo","children":[{"level":3,"title":"Cenário","slug":"cenario","link":"#cenario","children":[]},{"level":3,"title":"Descrição dos Componentes:","slug":"descricao-dos-componentes","link":"#descricao-dos-componentes","children":[]}]},{"level":2,"title":"Referência","slug":"referencia","link":"#referencia","children":[]}],"git":{"createdTime":1727703645000,"updatedTime":1727703645000,"contributors":[{"name":"Leandro Costa","email":"leandro.costa@ifba.edu.br","commits":1}]},"readingTime":{"minutes":0.17,"words":51},"filePathRelative":"posts/Seminarios/seminario-2/Adapter.md","localizedDate":"22 de agosto de 2024","autoDesc":true}');export{g as comp,h as data};
