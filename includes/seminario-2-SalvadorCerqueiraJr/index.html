<!doctype html>
<html lang="pt-BR" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.8" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.31" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://20241-ifba-saj-ads-ppr.github.io/blog-material-aula/blog-material-aula/includes/seminario-2-SalvadorCerqueiraJr/"><meta property="og:site_name" content="20241 PPR Blog das Aulas"><meta property="og:title" content="Adapter"><meta property="og:description" content="Adapter O Adapter é um padrão de projeto estrutural que permite objetos com interfaces incompatíveis colaborarem entre si. Intenção Converter a interface de uma classe em outra ..."><meta property="og:type" content="article"><meta property="og:image" content="https://github.com/user-attachments/assets/cb39c6fa-5ebb-4f6f-91af-891bd4a05f54"><meta property="og:locale" content="pt-BR"><meta property="article:author" content="Leandro Souza"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"Adapter","image":["https://github.com/user-attachments/assets/cb39c6fa-5ebb-4f6f-91af-891bd4a05f54","https://github.com/user-attachments/assets/2e8051f5-8b9d-4687-b54f-85e2b924e65b","https://github.com/user-attachments/assets/2943d0e9-5bd0-420f-9547-a7815c0d2836","https://github.com/user-attachments/assets/fcba4481-44b9-4d12-ba7a-51815367538e","https://github.com/user-attachments/assets/948d94dd-ec86-4e6e-a33c-40165d114503","https://github.com/user-attachments/assets/a58d043b-4180-4995-b902-583717ef9025","https://github.com/user-attachments/assets/0d69bf55-bbe3-473b-a8d9-84f8cd7572b6","https://github.com/user-attachments/assets/c09e9d4e-8550-40a6-a669-0aca05ca82c2","https://github.com/user-attachments/assets/8a2f00bd-9fcb-40b6-adc9-add084a6e771","https://github.com/user-attachments/assets/5b66ca13-4f3e-4b88-81ef-e0d06bee2478","https://github.com/user-attachments/assets/2da46f83-f4d7-4c47-b3d0-ee75468e331b","https://github.com/user-attachments/assets/f711c5a9-ee23-4a67-809f-dba2648057c9","https://github.com/user-attachments/assets/15744c1f-ef1b-4a59-bdba-cab9b6584d3f","https://github.com/user-attachments/assets/5dc6f9d8-3f8d-403d-8d74-ca72c0c9f2a9","https://github.com/user-attachments/assets/b1dea922-efc0-4b40-9709-927e42e1fc75","https://github.com/user-attachments/assets/e469e10f-3f20-4e60-aa56-2eb06fbac15e"],"dateModified":null,"author":[{"@type":"Person","name":"Leandro Souza","url":"https://github.com/leandro-costa"}]}</script><link rel="icon" href="/blog-material-aula/favicon.ico"><link rel="icon" href="/blog-material-aula/assets/icon/icon-512.png" type="image/png" sizes="512x512"><link rel="icon" href="/blog-material-aula/assets/icon/icon-192.png" type="image/png" sizes="192x192"><link rel="manifest" href="/blog-material-aula/manifest.webmanifest" crossorigin="use-credentials"><meta name="theme-color" content="#46bd87"><link rel="apple-touch-icon" href="/blog-material-aula/assets/icon/icon-152.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="msapplication-TileImage" content="/blog-material-aula/assets/icon/icon-144.png"><meta name="msapplication-TileColor" content="#ffffff"><title>Adapter | 20241 PPR Blog das Aulas</title><meta name="description" content="Adapter O Adapter é um padrão de projeto estrutural que permite objetos com interfaces incompatíveis colaborarem entre si. Intenção Converter a interface de uma classe em outra ...">
    <link rel="preload" href="/blog-material-aula/assets/style-BdBTOwGZ.css" as="style"><link rel="stylesheet" href="/blog-material-aula/assets/style-BdBTOwGZ.css">
    <link rel="modulepreload" href="/blog-material-aula/assets/app-BrOvOMMH.js"><link rel="modulepreload" href="/blog-material-aula/assets/index.html-BumIzlD7.js"><link rel="modulepreload" href="/blog-material-aula/assets/plugin-vue_export-helper-DlAUqK2U.js">
    
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">Pular para o conteúdo</a><!--]--><!--[--><div class="theme-container no-sidebar has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="route-link vp-brand" href="/blog-material-aula/"><img class="vp-nav-logo" src="/blog-material-aula/logo.svg" alt><!----><span class="vp-site-name hide-in-pad">20241 PPR Blog das Aulas</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><nav class="vp-nav-links"><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/blog-material-aula/" aria-label="PPR"><span class="font-icon icon iconfont icon-home" style=""></span>PPR<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/blog-material-aula/article/" aria-label="Publicações"><span class="font-icon icon iconfont icon-edit" style=""></span>Publicações<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/blog-material-aula/category/" aria-label="Categoria"><span class="font-icon icon iconfont icon-categoryselected" style=""></span>Categoria<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/blog-material-aula/tag/" aria-label="Tag"><span class="font-icon icon iconfont icon-tag" style=""></span>Tag<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/blog-material-aula/category/exercicio/" aria-label="Exercícios"><span class="font-icon icon iconfont icon-study" style=""></span>Exercícios<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/blog-material-aula/category/entrega/" aria-label="Para Entrega"><span class="font-icon icon iconfont icon-study" style=""></span>Para Entrega<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/blog-material-aula/timeline/" aria-label="Timeline"><span class="font-icon icon iconfont icon-time" style=""></span>Timeline<!----></a></div></nav><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><div class="nav-item vp-repo"><a class="vp-repo-link" href="https://github.com/20241-ifba-saj-ads-ppr/blog-material-aula" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!--[--><!----><!--]--><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->Adapter</h1><div class="page-info"><span class="page-author-info" aria-label="Autor🖊" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://github.com/leandro-costa" target="_blank" rel="noopener noreferrer">Leandro Souza</a></span><span property="author" content="Leandro Souza"></span></span><!----><!----><!----><span class="page-reading-time-info" aria-label="Tempo de Leitura⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>Por volta de 11 min</span><meta property="timeRequired" content="PT11M"></span><!----><!----></div><hr></div><div class="vp-toc-placeholder"><aside id="toc"><!--[--><!----><!--]--><div class="vp-toc-header">Nesta Página<button type="button" class="print-button" title="Imprimir"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button><div class="arrow end"></div></div><div class="vp-toc-wrapper"><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/blog-material-aula/#intencao">Intenção</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/blog-material-aula/#tambem-conhecido-como">Também conhecido como</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/blog-material-aula/#motivacao">Motivação</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/blog-material-aula/#aplicabilidade">Aplicabilidade</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/blog-material-aula/#estrutura">Estrutura</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/blog-material-aula/#participantes">Participantes</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/blog-material-aula/#colaboracoes">Colaborações</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/blog-material-aula/#consequencias">Conseqüências</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/blog-material-aula/#implementacao">Implementação</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/blog-material-aula/#exemplo-de-codigo">Exemplo de código</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/blog-material-aula/#usos-conhecidos">Usos conhecidos</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/blog-material-aula/#padroes-relacionados">Padrões relacionados</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/blog-material-aula/#meu-exemplo">Meu exemplo</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/blog-material-aula/#cenario">Cenário</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/blog-material-aula/#descricao-dos-componentes">Descrição dos Componentes:</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/blog-material-aula/#referencia">Referência</a></li><!----><!--]--></ul><div class="vp-toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!--[--><!----><!--]--><div class="theme-hope-content"><h1 id="adapter" tabindex="-1"><a class="header-anchor" href="#adapter"><span>Adapter</span></a></h1><p>O Adapter é um padrão de projeto estrutural que permite objetos com interfaces incompatíveis colaborarem entre si.</p><h2 id="intencao" tabindex="-1"><a class="header-anchor" href="#intencao"><span>Intenção</span></a></h2><p>Converter a interface de uma classe em outra interface, esperada pelos clientes. O Adapter permite que classes com interfaces incompatíveis trabalhem em conjunto – o que, de outra forma, seria impossível.</p><h2 id="tambem-conhecido-como" tabindex="-1"><a class="header-anchor" href="#tambem-conhecido-como"><span>Também conhecido como</span></a></h2><p>Wrapper</p><h2 id="motivacao" tabindex="-1"><a class="header-anchor" href="#motivacao"><span>Motivação</span></a></h2><p>Algumas vezes, uma classe de um toolkit, projetada para ser reutilizada não é reutilizável porque sua interface não corresponde à interface específica de um domínio requerida por uma aplicação.</p><p>Considere, por exemplo, um editor de desenhos que permite aos usuários desenhar e arranjar elementos gráficos (linhas, polígonos, texto, etc.) em figuras e diagramas. A abstração-chave do editor de desenhos é o objeto gráfico, o qual tem uma forma editável e pode desenhar a si próprio. A interface para objetos gráficos é definida por uma classe abstrata chamada Shape. O editor define uma subclasse de Shape para cada tipo de objeto gráfico: uma classe LineShape para linhas, uma classe PolygonShape para polígonos, e assim por diante.</p><p>Classes para formas geométricas elementares, como LineShape e PolygonShape, são bastante fáceis de ser implementadas porque as suas capacidades de desenho e edição são inerentemente limitadas. Mas uma subclasse TextShape que pode exibir e editar textos é mais difícil de ser implementada, uma vez que mesmo a edição básica de textos envolve atualizações complicadas de tela e gerência de buffer. Entretanto, pode já existir um toolkit para construção de interfaces de usuários, o qual já oferece uma sofisticada classe TextView para a exibição e edição de textos. Idealmente, gostaríamos de reutilizar TextView para implementar TextShape, porém, o toolkit não foi projetado levando classes Shape em consideração. Assim, não podemos usar de maneira intercambiável objetos TextView e Shape.</p><p>Como é possível que classes existentes e não-relacionadas, como TextView, funcionem em uma aplicação que espera classes com uma interface diferente e incompatível? Poderíamos mudar a classe TextView de maneira que ela fosse coerente com a interface de Shape, porém, a menos que tenhamos o código-fonte do toolkit, essa opção não é viável. Mesmo que tivéssemos o código-fonte, não teria sentido mudar TextView; o toolkit não deveria ter que adotar interfaces específicas de domínios somente para fazer com que uma aplicação funcione.</p><p>Em vez disso, poderíamos definir TextShape de maneira que ele adapte a interface de TextView àquela de Shape. Podemos fazer isto de duas maneiras: (1) herdando a interface de Shape e a implementação de TextView, ou (2) compondo uma instância de TextView dentro de uma TextShape e implementando TextShape em termos da interface de TextView.</p><p>Essas duas abordagens correspondem às versões do padrão Adapter para classes e para objetos. Chamamos TextShape um adaptador.</p><figure><img src="https://github.com/user-attachments/assets/cb39c6fa-5ebb-4f6f-91af-891bd4a05f54" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>Este diagrama ilustra o caso de um adaptador para objetos. Ele mostra como solicitações de BoundingBox, declarada na classe Shape, são convertidas em solicitações para GetExtent, definida em TextView. Uma vez que TextShape adapta Text View à interface de Shape, o editor de desenhos pode reutilizar a classe TextView que seria incompatível de outra forma.</p><p>Freqüentemente, um adaptador é responsável por funcionalidades não oferecidas pela classe adaptada. O diagrama mostra como um adaptador pode atender tais responsabilidades. O usuário deveria ser capaz de “arrastar” cada objeto Shape para uma nova posição de forma interativa, porém, TextView não está projetada para fazer isso. TextShape pode acrescentar essa função através da implementação da operação CreateManipulator, de Shape, a qual retorna uma instância da subclasse Manipulator apropriada.</p><p>Manipulator é uma classe abstrata para objetos que sabem como animar um Shape em resposta à entrada de usuário, tal como arrastar a forma geométrica para uma nova localização. Existem subclasses de Manipulator para diferentes formas; por exemplo, TextManipulator é a subclasse correspondente para TextShape. Pelo retorno de uma instância de TextManipulator, TextShape acrescenta a funcionalidade que Shape necessita mas que TextView não tem.</p><h2 id="aplicabilidade" tabindex="-1"><a class="header-anchor" href="#aplicabilidade"><span>Aplicabilidade</span></a></h2><p>Use o padrão Adapter quando:</p><ul><li>você quiser usar uma classe existente, mas sua interface não corresponder à interface de que necessita;</li><li>você quiser criar uma classe reutilizável que coopere com classes não-relacionadas ou não-previstas, ou seja, classes que não necessariamente tenham interfaces compatíveis:</li><li>(somente para adaptadores de objetos) você precisar usar várias subclasses existentes, porém, for impraticável adaptar essas interfaces criando subclasses para cada uma. Um adaptador de objeto pode adaptar a interface da sua classe-mãe.</li></ul><h2 id="estrutura" tabindex="-1"><a class="header-anchor" href="#estrutura"><span>Estrutura</span></a></h2><ul><li><p>Um adaptador de classe usa a herança múltipla para adaptar uma interface à outra: <img src="https://github.com/user-attachments/assets/2e8051f5-8b9d-4687-b54f-85e2b924e65b" alt="image" loading="lazy"></p></li><li><p>Um adaptador de objeto depende da composição de objetos: <img src="https://github.com/user-attachments/assets/2943d0e9-5bd0-420f-9547-a7815c0d2836" alt="image" loading="lazy"></p></li></ul><h2 id="participantes" tabindex="-1"><a class="header-anchor" href="#participantes"><span>Participantes</span></a></h2><ul><li>Target (Shape): define a interface específica do domínio que Client usa.</li><li>Client (DrawingEditor): colabora com objetos compatíveis com a interface de Target.</li><li>Adaptee (TextView): define uma interface existente que necessita ser adaptada.</li><li>Adapter (TextShape): adapta a interface do Adaptee à interface de Target.</li></ul><h2 id="colaboracoes" tabindex="-1"><a class="header-anchor" href="#colaboracoes"><span>Colaborações</span></a></h2><p>• Os clientes chamam operações em uma instância de Adapter. Por sua vez, o adapter chama operações de Adaptee que executam a solicitação.</p><h2 id="consequencias" tabindex="-1"><a class="header-anchor" href="#consequencias"><span>Conseqüências</span></a></h2><p>Os adaptadores de classes e de objetos têm diferentes soluções de compromisso. Um adaptador de classe:</p><ul><li>adapta Adaptee a Target através do uso efetivo de uma classe Adapter concreta. Em conseqüência, um adaptador de classe não funcionará quando quisermos adaptar uma classe e todas as suas subclasses;</li><li>permite a Adapter substituir algum comportamento do Adaptee, uma vez que Adapter é uma subclasse de Adaptee;</li><li>introduz somente um objeto, e não é necessário endereçamento indireto adicional por ponteiros para chegar até o Adaptee.</li></ul><p>Um adaptador de objeto:</p><ul><li>permite a um único Adapter trabalhar com muitos Adaptees – isto é, o Adaptee em si e todas as suas subclasses (se existirem). O Adapter também pode acrescentar funcionalidade a todos os Adaptees de uma só vez;</li><li>torna mais difícil redefinir um comportamento de Adaptee. Ele exigirá a criação de subclasses de Adaptee e fará com que Adapter referencie a subclasse ao invés do Adaptee em si.</li></ul><p>Aqui apresentamos outros pontos a serem considerados quando usamos o padrão Adapter:</p><ol><li><p>Quanta adaptação Adapter faz? Os Adapters variam no volume de trabalho que executam para adaptar o Adaptee à interface de Target. Existe uma variação do trabalho possível, desde a simples conversão de interface – por exemplo, mudar os nomes das operações – até suportar um conjunto de operações inteiramente diferente. O volume de trabalho que o Adapter executa depende de quão similar é a interface de Target a dos seus Adaptees.</p></li><li><p>Adaptadores conectáveis (pluggable). Uma classe é mais reutilizável quando você minimiza as suposições que outras classes devem fazer para utilizá-la. Através da construção da adaptação de interface em uma classe, você elimina a suposição de que outras classes vêm a mesma interface. Dito de outra maneira, a adaptação de interfaces permite incorporar a nossa classe a sistemas existentes que podem estar esperando interfaces diferentes para a classe. ObjectWorks/ Smalltalk [Par90] usa o termo pluggable adapter para descrever classes com adaptação de interfaces incorporadas. Considere um widget TreeDisplay que pode exibir graficamente estruturas de árvore. Se este fosse um widget com uma finalidade especial para uso em apenas uma aplicação, então, poderíamos requerer uma interface específica dos objetos que ele exibisse; ou seja, todos deveriam descender de uma classe abstrata Tree. Mas se quiséssemos tornar TreeDisplay mais reutilizável (digamos que quiséssemos torná-la parte de um toolkit de widgets úteis), então essa exigência não seria razoável. Aplicações definirão suas próprias classes para estruturas de árvore. Elas não deveriam ser forçadas a usar a nossa classe abstrata Tree. Diferentes estruturas de árvores terão diferentes interfaces. Por exemplo, numa hierarquia de diretório, os descendentes podem ser acessados com uma operação GetSubdirectories, enquanto que numa hierarquia de herança, a operação correspondente poderia ser chamada GetSubclasses. Um widget TreeDisplay reutilizável deve ser capaz de exibir ambos os tipos de hierarquias ainda que usem interfaces diferentes. Em outras palavras, TreeDisplay deveria ter uma adaptação de interface incorporada a ele. Examinaremos diferentes maneiras de construir adaptações de interfaces, dentro de classes, na seção Implementação.</p></li><li><p>Utilização de adaptadores de dois sentidos para fornecer transparência. Um problema potencial com adaptadores decorre do fato de que eles não são transparentes para todos os clientes. Um objeto adaptado não oferece a interface do objeto original, por isso ele não pode ser usado onde o original o for. Adaptadores de dois sentidos (two-way adapters) podem fornecer essa transparência. Eles são úteis quando dois clientes diferentes necessitam ver um objeto de forma diferente. Considere o adaptador de dois sentidos que integra o Unidraw, um framework para editores gráficos [VL90], e QOCA, um toolkit para solução de restrições [HHMV92]. Ambos os sistemas possuem classes que representam variáveis explicitamente: Unidraw tem StateVariable e QOCA tem Constraint Variable. Para fazer com que Unidraw trabalhe com QOCA, Constraint Variable deve ser adaptada a StateVariable; para permitir que QOCA propague soluções para Unidraw, StateVariable deve ser adaptada a ConstraintVariable.</p></li></ol><figure><img src="https://github.com/user-attachments/assets/fcba4481-44b9-4d12-ba7a-51815367538e" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>A solução envolve o uso de um adaptador de classe ConstraintStateVariable de dois sentidos, uma subclasse tanto de StateVariable como de ConstraintVariable que adapta as duas interfaces uma à outra. Neste caso, a herança múltipla é uma solução viável porque as interfaces das classes adaptadas são substancialmente diferentes. O adaptador de classe de dois sentidos é compatível com ambas as classes adaptadas, podendo funcionar em ambos os sistemas.</p><h2 id="implementacao" tabindex="-1"><a class="header-anchor" href="#implementacao"><span>Implementação</span></a></h2><p>Embora a implementação do padrão Adapter seja normalmente simples e direta, apresentamos aqui alguns tópicos a serem sempre considerados:</p><ol><li>Implementando adaptadores de classe em C++. Numa implementação em C++ uma classe Adapter deveria herdar publicamente de Target e privadamente de Adaptee. Assim, Adapter seria um subtipo de Target, mas não de Adaptee.</li><li>Adaptadores conectáveis. Vamos examinar três maneiras de implementar adaptadores “plugáveis” para o widget TreeDisplay descrito anteriormente, os quais podem formatar e exibir uma estrutura hierárquica automaticamente. O primeiro passo, comum a todas as três implementações discutidas aqui, é encontrar uma interface “mínima” para Adaptee, ou seja, o menor subconjunto de operações que permite fazer a adaptação. Uma interface mínima, consistindo em somente um par de operações, é mais fácil de adaptar que uma interface com dúzias de operações. Para o TreeDisplay, o adaptee é qualquer estrutura hierárquica. Uma interface minimalista pode incluir duas operações, uma que define como apresentar graficamente um nó na estrutura hierárquica e outra que recupera os filhos do nó. A interface mínima conduz a três abordagens de implementação:</li></ol><p>(a) Utilizando operações abstratas. Defina na classe TreeDisplay operações abstratas correspondentes à interface mínima de Adaptee. As operações abstratas devem ser implementadas por subclasses que também adaptam o objeto hierarquicamente estruturado. Por exemplo, uma subclasse DirectoryTreeDisplay implementará essas operações acessando a estrutura do diretório.</p><figure><img src="https://github.com/user-attachments/assets/948d94dd-ec86-4e6e-a33c-40165d114503" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>DirectoryTreeDisplay especializa a interface mínima de maneira que possa exibir estruturas de diretório compostas de objetos FileSystemEntity.</p><p>(b) Utilizando objetos delegados. Nesta abordagem, o TreeDisplay repassa solicitações de acesso à estrutura hierárquica para um objeto delegado. O TreeDisplay pode usar uma estratégia de adaptação diferente pela substituição de um delegado por outro. Por exemplo, suponha que exista um DirectoryBrowser que usa um TreeDisplay. Directory Browser pode vir a ser um bom delegado para adaptar TreeDisplay à estrutura do diretório hierárquico. Em linguagens com tipos definidos dinamicamente, como Smalltalk ou Objective C, essa abordagem somente exige uma interface para registrar o delegado junto ao adapter. Então, o TreeDisplay simplesmente repassa as solicitações para o delegado. NEXTSTEP [Add94] usa essa abordagem intensamente para reduzir o uso de subclasses. As linguagens com tipos estaticamente definidos, como C++, requerem uma definição explícita da interface para o delegado. Podemos especificar tal interface colocando a interface mínima requerida por TreeDisplay em uma classe abstrata TreeAccessorDelegate. Então, podemos misturar essa interface com o delegado de nossa escolha – DirectoryBrowser, neste caso – usando herança. Usamos herança simples se o DirectoryBrowse não tiver classe-mãe, caso contrário, usamos herança múltipla. Misturar classes dessa maneira é mais fácil do que introduzir uma nova subclasse TreeDisplay e implementar suas operações individualmente.</p><figure><img src="https://github.com/user-attachments/assets/a58d043b-4180-4995-b902-583717ef9025" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>(c) Adapters parametrizados.</p><p>A maneira usual de suportar adaptadores conectáveis em Smalltalk é parametrizar um adaptador com um ou mais blocos (Smalltalk). A primitiva “block” suporta a adaptação sem usar subclasses. Um bloco pode adaptar uma solicitação e o adaptador pode armazenar um bloco para cada solicitação individual. No nosso exemplo, isso significa que TreeDisplay armazena um bloco para converter um nó em um GraphicNode e outro bloco para acessar os filhos de um nó. Por exemplo, para criar um TreeDisplay em uma hierarquia de diretório, escrevemos</p><figure><img src="https://github.com/user-attachments/assets/0d69bf55-bbe3-473b-a8d9-84f8cd7572b6" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>Se você está construindo uma adaptação de interface em uma classe, essa abordagem oferece uma alternativa conveniente ao uso de subclasses.</p><h2 id="exemplo-de-codigo" tabindex="-1"><a class="header-anchor" href="#exemplo-de-codigo"><span>Exemplo de código</span></a></h2><p>Apresentaremos um breve esboço da implementação de adaptadores de classes e de objetos para o exemplo apresentado na seção Motivação, começando com as classes Shape e TextView.</p><figure><img src="https://github.com/user-attachments/assets/c09e9d4e-8550-40a6-a669-0aca05ca82c2" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>Shape supõe uma caixa delimitadora definida pelos seus cantos opostos. Em contraste, TextView é definido por origem, altura e largura. Shape também define uma operação CreateManipulator para criar um objeto Manipulator, o qual sabe como animar uma forma quando um usuário a manipula.1 O TextView não tem uma operação equivalente. A classe TextShape é um adaptador entre essas diferentes interfaces.</p><p>Um adaptador de classe utiliza a herança múltipla para adaptar interfaces. O ponto-chave dos adaptadores de classe é a utilização de um ramo de herança para herdar a interface e de outro ramo para herdar a implementação. A maneira usual de fazer essa distinção em C++ é herdar a interface publicamente e herdar a implementação privadamente. Usaremos essa convenção para definir o adaptador TextShape.</p><p>A operação BoundingBox converte a interface de TextView para que esta fique de acordo com a interface de Shape.</p><figure><img src="https://github.com/user-attachments/assets/8a2f00bd-9fcb-40b6-adc9-add084a6e771" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>A operação IsEmpty demonstra o repasse direto de solicitações, comum em implementações de adaptadores:</p><figure><img src="https://github.com/user-attachments/assets/5b66ca13-4f3e-4b88-81ef-e0d06bee2478" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>Finalmente, definimos CreateManipulator (a qual não é suportada por TextView) a partir do zero. Assumimos que já implementamos uma classe TextManipulator que suporta manipulação de um TextShape.</p><figure><img src="https://github.com/user-attachments/assets/2da46f83-f4d7-4c47-b3d0-ee75468e331b" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>O adaptador de objeto utiliza composição de objetos para combinar classes que têm interfaces diferentes. Nesta abordagem, o adaptador TextShape mantém um apontador para TextView.</p><figure><img src="https://github.com/user-attachments/assets/f711c5a9-ee23-4a67-809f-dba2648057c9" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>TextShape deve iniciar o apontador para instância de TextView, e ele faz isso no constructor. Ele também deve invocar operações no seu objeto TextView sempre que suas próprias operações forem invocadas. Neste exemplo, presuma que o cliente crie o objeto TextView e o passe para o constructor de TextShape:</p><figure><img src="https://github.com/user-attachments/assets/15744c1f-ef1b-4a59-bdba-cab9b6584d3f" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>A implementação de CreateManipulator não muda em relação à versão para o adaptador de classe, uma vez que é implementada do zero e não reutiliza qualquer funcionalidade existente de TextView.</p><figure><img src="https://github.com/user-attachments/assets/5dc6f9d8-3f8d-403d-8d74-ca72c0c9f2a9" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>Compare este código com o código do caso do adaptador de classe. O adaptador de objeto exige um pouco mais de esforço para escrever, porém, é mais flexível. Por exemplo, a versão do adaptador de objeto de TextShape funcionará igualmente bem com subclasses de TextView – o cliente simplesmente passa uma instância de uma subclasse de TextView para o constructor de TextShape.</p><h2 id="usos-conhecidos" tabindex="-1"><a class="header-anchor" href="#usos-conhecidos"><span>Usos conhecidos</span></a></h2><p>O exemplo da seção Motivação vem do ET++Draw, uma aplicação de desenho baseada na ET++ [WGM88]. O ET++Draw reutiliza as classes para edição de texto da ET++ usando um adapter de classe TextShape. O InterViews 2.6 define uma classe abstrata Interactor para elementos da interface do usuário, tais como barras de rolamento, botões e menus [VL88]. Ele também define uma classe abstrata Graphic para objetos gráficos estruturados, tais como linhas, círculos, polígonos e “splines”. Tanto Interactors como Graphics têm aparências gráficas, porém, diferentes interfaces e implementações (eles não têm uma classe ancestral compartilhada) e são, portanto, incompatíveis – você não pode incluir diretamente um objeto gráfico estruturado em, por exemplo, uma caixa de diálogo.</p><p>Em vez disso, o InterViews 2.6 define um adaptador de objeto chamado GraphicBlock, uma subclasse de Interactor que contém uma instância de Graphic. O GraphicBlock adapta a interface da classe Graphic àquela de Interactor. O GraphicBlock permite que uma instância de Graphic seja exibida, rolada e possa sofrer zooms dentro de uma estrutura Interactor. Os adaptadores conectáveis são comuns em ObjectWorks\Smalltalk. O Smalltalk-padrão define uma classe ValueModel para visões (views) que exibem um único valor. ValueModel define uma interface value, value: para acessar o valor. Estes são métodos abstratos. Programadores de aplicação acessam o valor usando nomes mais específicos do domínio, tais como width e width:, mas eles não deveriam ter que criar subclasses de ValueModel para adaptar tais nomes específicos da aplicação à interface de ValueModel.</p><p>Em vez disso, ObjectWorks\Smalltalk inclui uma subclasse de ValueModel chamada PluggableAdaptor. Um objeto PluggableAdaptor adapta outros objetos à interface de ValueModel (value, value:). Ela pode ser parametrizada com blocos para obter e atualizar (set) o valor desejado. PluggableAdaptor utiliza internamente estes blocos para implementar a interface value, value:. PluggableAdaptor também permite passar nomes no Selector (por exemplo, width, width:) diretamente por conveniência sintática. Ela converte estes seletores (selectors) nos blocos correspondentes, de forma automática.</p><figure><img src="https://github.com/user-attachments/assets/b1dea922-efc0-4b40-9709-927e42e1fc75" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>Outro exemplo proveniente de ObjectWorks\Smalltalk é a classe TableAdaptor. Uma TableAdaptor pode adaptar uma seqüência de objetos numa apresentação tabular. A tabela exibe um objeto por linha. O cliente parametriza TableAdaptor com um conjunto de mensagens que uma tabela pode usar para obter os valores de coluna de um objeto.</p><p>Algumas classes no AppKit do NeXT [Add94] usam objetos delegados para executar adaptação de interfaces. Um exemplo é a classe NXBrowser que pode exibir listas hierárquicas de dados. NXBrowser usa um objeto delegado para acessar e adaptar dados. O “Casamento de Conveniência” (“Marriage of Convenience”), [Mey88] de Meyer é uma forma de um adaptador de classe. Meyer descreve como uma classe FixedStack adapta a implementação de uma classe Array à interface de uma classe stack. O resultado é uma pilha (Stack) que contém um número fixo de entradas.</p><h2 id="padroes-relacionados" tabindex="-1"><a class="header-anchor" href="#padroes-relacionados"><span>Padrões relacionados</span></a></h2><p>O padrão Bridge(151) tem uma estrutura similar a um adaptador de objeto, porém, Bridge tem uma intenção diferente: tem por objetivo separar uma interface da sua implementação, de modo que elas possam variar fácil e independentemente. Um adaptador se destina a mudar a interface de um objeto existente.</p><p>O padrão Decorator (170) aumenta outro objeto sem mudar sua interface. Desta forma, um Decorator é mais transparente para a aplicação do que um adaptador.</p><p>Como conseqüência, Decorator suporta a composição recursiva, a qual não é possível com adaptadores puros.</p><p>O Proxy (198) define um representante ou “procurador”para outro objeto e nãomuda a sua interface.</p><h2 id="meu-exemplo" tabindex="-1"><a class="header-anchor" href="#meu-exemplo"><span>Meu exemplo</span></a></h2><h3 id="cenario" tabindex="-1"><a class="header-anchor" href="#cenario"><span>Cenário</span></a></h3><p>Você tem um sistema de carga de veículos elétricos que precisa lidar com diferentes tipos de conectores de carga, como o Tipo 1 e o Tipo 2. O sistema deve oferecer uma interface uniforme para carregar o veículo, independentemente do tipo de conector.</p><figure><img src="https://github.com/user-attachments/assets/e469e10f-3f20-4e60-aa56-2eb06fbac15e" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><h3 id="descricao-dos-componentes" tabindex="-1"><a class="header-anchor" href="#descricao-dos-componentes"><span>Descrição dos Componentes:</span></a></h3><ol><li>SistemaDeCarga: Classe que precisa carregar o veículo elétrico e interage com a interface Conector.</li><li>Conector: Interface que define o método conectar(), que o SistemaDeCarga espera.</li><li>AdaptadorTipo1: Classe que adapta o conector Tipo 1 para a interface Conector. Implementa o método conectar() usando uma instância de ConectorTipo1.</li><li>AdaptadorTipo2: Classe que adapta o conector Tipo 2 para a interface Conector. Implementa o método conectar() usando uma instância de ConectorTipo2.</li><li>ConectorTipo1: Classe que representa um conector de tipo 1 com o método conectarTipo1().</li><li>ConectorTipo2: Classe que representa um conector de tipo 2 com o método conectarTipo2().</li></ol><h2 id="referencia" tabindex="-1"><a class="header-anchor" href="#referencia"><span>Referência</span></a></h2><ol><li>AMMA, Erich. et al. Padrões de projetos: Soluções reutilizáveis de software orientados a objetos Bookman editora, 2009.</li></ol></div><!--[--><!----><!--]--><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/20241-ifba-saj-ads-ppr/blog-material-aula/edit/main/src/includes/seminario-2-SalvadorCerqueiraJr/README.md" rel="noopener noreferrer" target="_blank" aria-label="Edite esta pagina no GitHub" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->Edite esta pagina no GitHub<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><!----><!----></div></footer><!----><!----><!--[--><!----><!--]--><!--]--></main><!--]--><footer class="vp-footer-wrapper"><div class="vp-footer">Material de aula IFBA SAJ</div><div class="vp-copyright">Copyright © 2024 Leandro Souza </div></footer></div><!--]--><!--]--><!--[--><!----><!----><!--]--><!--]--></div>
    <script type="module" src="/blog-material-aula/assets/app-BrOvOMMH.js" defer></script>
  </body>
</html>
